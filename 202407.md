# 7/1(Mon)
## Apple Vision Proについて
![image](https://github.com/PEARLabo/diary/assets/166197812/df6d219d-ac94-437f-b206-92c9af1bd3f1)  
*Apple Vision Proのアイトラッキング技術について*  
そもそもApple Vision Proとは空間コンピューティングデバイスである。コントローラであるポインティングデバイスは、装着しているユーザの「目線」である。  
Vision Proはユーザの目の動きをセンサで検出し、その視線が捉えている対象を特定することができる。この技術を、アイトラッキング技術と呼ぶ。  
アイトラッキングはすでに様々な分野で実用化されている。  
- メガネ型の視線追跡デバイス:自動車や鉄道など交通機関の運転手や航空機の操縦士の訓練に利用されており、運転中の周囲への注意や計器類の確認などを計測することに役立っている。
- 消費者の目線を追跡する:どのような情報に関心を持っているのかを計測し、パッケージデザインや棚割りなどマーケティングに活かすといった用途にも用いられる。
一方でアイトラッキング技術は、手などが自由に動かせないユーザのコミュニケーションツールとしても利用されている。

<img width="412" alt="image" src="https://github.com/PEARLabo/diary/assets/166197812/e2075bfb-2f8b-4a9d-a8c7-126105c4290f">  

基本的な動作原理はメガネ型と同じだが、細長い形状の視線追跡デバイスがディスプレイ下部に取り付けられており、利用者の視線の動きを追跡してポインタを移動させる。
*角膜反射によるアイトラッキング*
アイトラッキングは様々な方式が実用化されているが、Vision Proが採用しているのはセンサの種類とその配置から角膜反射と呼ばれる方式で間違いないと思われる。

<img width="415" alt="image" src="https://github.com/PEARLabo/diary/assets/166197812/ac7dd1b8-2d13-4a2e-9294-25f8a8541059">  

人間の目（表面の見える部分）は、白目と呼ばれる表面の膜状の「強膜」と、黒目と呼ばれるレンズ状の「角膜」で構成され、さらに角膜は中心部の「瞳孔」とそれを取り巻く「虹彩」で構成されている。
角膜反射方式では、視線の方向を検出するのに瞳孔と基準点の位置関係を利用しており、目の前方にLEDの点光源を配置し、その光源が瞳(角膜)に映り込んだ像（プルキニエ像）を基準点として、瞳孔の中心部の方向と距離から視線の方向を算出する仕組みである。
LED光源が可視光だとユーザの視界を妨げることから、その光源には目に見えない近赤外LEDが用いられており、目の周り全体を撮影するのに赤外カメラが使われている。
角膜反射方式における視線測定精度は0.5度程度とされており、様々なアイトラッキング技術の中でも高い精度を誇るにが特徴である。  
Vision Proでは、片目あたり10個以上の近赤外LED光源と２個の赤外カメラが搭載されており、目の大きさや周りの形状の違いなどの影響を最小限に抑えることで、高精度で安定したトラッキングができるよう工夫されている。
*ストレスのない空間コンピュータ*  
アイトラッキングでは、４つの近赤外線カメラより得られたイメージから瞳孔とプルキニエ像を識別し、その情報をもとにユーザの視線の先を高い精度で計算しなければならない。高度なアイトラッキング技術も、その処理に遅延が発生するとユーザエクスペリエンスが大幅に低下してしまうからである。  
さらに、視線入力を反映させる先は、８個の外部カメラを含むセンサ類が捉えた現実空間をベースに再生成された仮想空間と、その上にリアルタイム３Dマッピングされた仮想オブジェクトで構成された２つ（両目）のスクリーンが対象である。これらを高解像度かつリアルタイムに処理するため専用に開発されたのが、空間処理を担うカスタムチップ「R１」である。  

<img width="413" alt="image" src="https://github.com/PEARLabo/diary/assets/166197812/c8aef28a-5df4-4eab-a780-6d16212f7e70">  

R1の役割は、このような複雑な空間処理を、メインプロセッサであるM２からオフロードすることで、空間処理の高速化を実現すると同時に、M２の負荷を下げて発熱や消費電力を抑制する働きにある。さらに、R1が独立して空間処理を行うため、M２の負荷状態に影響を受けず、どのような状況でも遅延の極めて少ない良質なユーザエクスペリエンスを提供できるというメリットがある。

# 7/3(Wed)
## code convertについて
アセンブリ言語からC言語に変換する際には、無料版であるとすぐに規定量をオーバーしてしまい有用性は低いように感じられた。しかしながら、有料版ではその有用性が発揮されると思われる。さらにシンボル名は見やすいものではないようになった。他では、C言語からPythonの変換では、とても精度が高く変換されていた。

## ghidraスクリプトからシンボル名推論を行う
欲しいC言語ソース
```c
#include <stdio.h>

int my_sum(int* ,int);

int main(){
	int ary[5] = {1,2,3,4,5};
	int sum = 0;
	int i;

	sum = my_sum(ary,sizeof(ary) / sizeof(int));

	for(i=0;i<5;i++){
		printf("%d ",ary[i]);
	}

	printf("\n");

	printf("sum = %d\n",sum);	

	return 0;
}

int my_sum(int* ary,int size){
	int sum = 0;
	int i;
	
	for(i=0;i<size;i++){
		sum += *(ary + i);
	}

	return sum;
}
```
逆アセンブリしたもの(main関数)
```

undefined8 main(void)

{
  uint uVar1;
  long in_FS_OFFSET;
  int local_30;
  uint local_28 [4];
  undefined4 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28[0] = 1;
  local_28[1] = 2;
  local_28[2] = 3;
  local_28[3] = 4;
  local_18 = 5;
  uVar1 = my_sum(local_28,5);
  for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
    printf("%d ",(ulong)local_28[local_30]);
  }
  putchar(10);
  printf("sum = %d\n",(ulong)uVar1);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
(my_sum関数)
```

int my_sum(long param_1,int param_2)

{
  int local_10;
  int local_c;
  
  local_10 = 0;
  for (local_c = 0; local_c < param_2; local_c = local_c + 1) {
    local_10 = local_10 + *(int *)(param_1 + (long)local_c * 4);
  }
  return local_10;
}
```
以下のPythonコードをScript Managerで用いた。
```py
# Import necessary Ghidra classes
# 必要なGhidraクラスとPythonの標準ライブラリをインポートする。
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.model.symbol import SymbolUtilities
from ghidra.app.script import GhidraScript
import re

# Create a class that inherits from GhidraScript
# GhidraScriptクラスを継承する新しいクラスを定義する。
class HumanReadableSymbolInferenceScript(GhidraScript):

    def run(self):
        # Get the current program
        # 現在のプログラムを取得する。
        current_program = self.getCurrentProgram()
        
        # Get the current address
	# 現在のアドレスを取得する。
        current_address = self.getCurrentAddress()
	# アドレスがない場合はメッセージを出力して終了する。
        if current_address is None:
            self.println("No current address!")
            return
        
        # Get the function at the current address
	# 現在のアドレスに含まれる関数を取得する。
        function = self.getFunctionContaining(current_address)

	# 関数がない場合はメッセージを出力して終了する。
        if function is None:
            self.println("No function selected!")
            return
        
        # Print the function name
	# 関数名を出力する。
        function_name = function.getName()
        self.println("Function name: " + function_name)

        # Initialize the decompiler
	# デコンパイラを初期化し、現在のプログラムを開く。
        decompiler = DecompInterface()
        decompiler.openProgram(current_program)
        
        # Decompile the selected function
	# 選択された関数をデコンパイルする。
        decompiled = decompiler.decompileFunction(function, 60, ConsoleTaskMonitor())
        
        if decompiled.decompileCompleted():
            # Get the decompiled C code
	    # デコンパイルが成功した場合、デコンパイルされたCコードを取得して出力する。
            c_code = decompiled.getDecompiledFunction().getC()
            self.println("Original Decompiled C code:")
            self.println(c_code)
            
            # Analyze the decompiled C code for symbol names
            # Cコードを解析してシンボル名を推論し、推論されたシンボル名を出力する。
            inferred_symbols = self.infer_symbols(c_code)
            self.println("Inferred Symbols:")
            for symbol in inferred_symbols:
                self.println(symbol)
            
            # Modify the C code with inferred symbols
            # 推論されたシンボル名を使用してCコードを修正し、修正後のCコードを出力する。
            # デコンパイルが失敗した場合、エラーメッセージを出力する。
            modified_c_code = self.apply_inferred_symbols(c_code, inferred_symbols)
            self.println("\nModified Decompiled C code:")
            self.println(modified_c_code)
        else:
            self.println("Decompilation failed!")

    def infer_symbols(self, c_code):
        inferred_symbols = []
        variable_counter = {}
        
        # Regular expression patterns to match variable declarations
	# 変数宣言にマッチする正規表現パターンのリストを定義する。
        patterns = [
            r'\bint\s+(\w+)',
            r'\bchar\s+(\w+)',
            r'\bfloat\s+(\w+)',
            r'\bdouble\s+(\w+)',
            r'\bvoid\s+(\w+)',
            r'\blong\s+(\w+)',
            r'\bshort\s+(\w+)',
            r'\bunsigned\s+(\w+)',
            r'\bsigned\s+(\w+)',
        ]

        # 各パターンについて、Cコード内の一致を見つけ、カウンターを増やす。
        for pattern in patterns:
            matches = re.findall(pattern, c_code)
            for match in matches:
                if match in variable_counter:
                    variable_counter[match] += 1
                else:
                    variable_counter[match] = 1
                
                # Generate a human-readable name based on the type and counter
                # 基本名とカウンターを使って人間が読みやすい名前を生成し、推論されたシンボルとしてリストに追加する。
                human_readable_name = self.generate_human_readable_name(match, variable_counter[match])
                inferred_symbols.append((match, human_readable_name))
        # 推論されたシンボルのリストを返す。
        return inferred_symbols

    def generate_human_readable_name(self, base_name, count):
        # Generate a human-readable name based on a simple heuristic
        # 基本名とカウンターを使って、人間が読みやすい名前を生成する。
        return base_name + "_var" + str(count)

    def apply_inferred_symbols(self, c_code, inferred_symbols):
        # Replace original variable names with inferred human-readable names
        # 元の変数名を推論された人間が読みやすい名前に置き換える。
        modified_code = c_code
        for original_name, human_readable_name in inferred_symbols:
            modified_code = re.sub(r'\b' + re.escape(original_name) + r'\b', human_readable_name, modified_code)
        # 修正されたコードを返す。
        return modified_code

# The script entry point is handled by Ghidra
# Ghidraがスクリプトのエントリーポイントを管理する。
```
# 7/10(Wed)
```c
#include <stdio.h>


void function1(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


void function2(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main() {
    int arr[100000];  

    
    for (int i = 0; i < 100000; i++) {
        arr[i] = i + 1;
    }

    
    function2(arr, 100000);

    
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```


```py
import re
from difflib import SequenceMatcher
from transformers import AutoModelForCausalLM, AutoTokenizer
from sentence_transformers import SentenceTransformer, util

# 事前に定義された関数名リスト
known_function_names = [
    "swap_elements",
    "sort_array",
    "merge_sort",
    "calculate_average",
    "find_maximum",
    "find_minimum",
    "reverse_string",
    # 今回は実験として、これらの関数名を追加して実行した
]

# 使用するモデルとトークナイザーの初期化（例：GPT-2とSentenceTransformer）
model_name_or_path = "gpt2"
tokenizer = AutoTokenizer.from_pretrained(model_name_or_path)
model = AutoModelForCausalLM.from_pretrained(model_name_or_path)

# パディングトークンを追加
if tokenizer.pad_token_id is None:
    tokenizer.add_special_tokens({'pad_token': '[PAD]'})
    model.resize_token_embeddings(len(tokenizer))

# SentenceTransformerモデルの初期化（例：bert-base-nli-mean-tokens）
sentence_model = SentenceTransformer('bert-base-nli-mean-tokens')

# 関数名を推論する関数
def infer_function_name(code_snippet, max_length=50):
    # コードスニペットを基に関数名を推論する処理
    prompt = f"Suggest a function name for the following code:\n\n{code_snippet}\n\nFunction name:"
    inputs = tokenizer(prompt, return_tensors='pt', max_length=512, truncation=True)
    input_ids = inputs['input_ids']
    attention_mask = inputs['attention_mask']

    output = model.generate(input_ids, attention_mask=attention_mask, max_length=max_length, num_return_sequences=1, pad_token_id=tokenizer.pad_token_id)
    generated_name = tokenizer.decode(output[0], skip_special_tokens=True).strip()

    # 事前に定義された関数名リストとの類似度を計算する（例として文の埋め込みを使用）
    embeddings_known = sentence_model.encode(known_function_names)
    embedding_generated = sentence_model.encode(generated_name)

    # 最も類似した関数名を選択する
    similarity_scores = util.pytorch_cos_sim(embeddings_known, embedding_generated)
    best_match_index = similarity_scores.argmax().item()
    best_match = known_function_names[best_match_index]

    return best_match

# コードから関数の内容を抽出する関数（例としてC言語の関数を想定）
def extract_functions_from_code(code):
    pattern = re.compile(r'void\s+(\w+)\s*\(.*?\)\s*\{.*?\}', re.DOTALL)
    matches = pattern.findall(code)
    return matches

# ファイルからコードを読み込む関数
def read_code_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as file:
        return file.read()

# コードから関数名を推論して出力するメイン関数
def main(file_path):
    # コードを読み込む
    code = read_code_file(file_path)

    # コードから関数を抽出する
    functions = extract_functions_from_code(code)

    # 関数名の推論と出力
    for function_code in functions:
        suggested_name = infer_function_name(function_code)
        print(f"Suggested name: {suggested_name}\nFunction code:\n{function_code}\n")

# メイン関数の呼び出し
if __name__ == "__main__":
    source_file_path = 'source.c'
    main(source_file_path)
```
上のソースにより以下の実行結果が得られた。  
![Screenshot from 2024-07-10 16-16-19](https://github.com/PEARLabo/diary/assets/166197812/da1f0060-2f1a-4508-ab54-f69a4f974584)  
関数名の推論結果が得られた。次に推論された関数名に置き換えたソースコードを出力するようにした。以下がそれである。  
```py
import re
from difflib import SequenceMatcher
from transformers import AutoModelForCausalLM, AutoTokenizer
from sentence_transformers import SentenceTransformer, util

# 事前に定義された関数名リスト
known_function_names = [
    "swap_elements",
    "sort_array",
    "merge_sort",
    "calculate_average",
    "find_maximum",
    "find_minimum",
    "reverse_string",
    # 今回は実験として、これらの関数名を追加して実行した
]

# 使用するモデルとトークナイザーの初期化（GPT-2とSentenceTransformer）
model_name_or_path = "gpt2"
tokenizer = AutoTokenizer.from_pretrained(model_name_or_path)
model = AutoModelForCausalLM.from_pretrained(model_name_or_path)

# パディングトークンを追加
if tokenizer.pad_token_id is None:
    tokenizer.add_special_tokens({'pad_token': '[PAD]'})
    model.resize_token_embeddings(len(tokenizer))

# SentenceTransformerモデルの初期化（bert-base-nli-mean-tokens）
sentence_model = SentenceTransformer('bert-base-nli-mean-tokens')

# 関数名を推論する関数
def infer_function_name(code_snippet, max_new_tokens=10):
    # コードスニペットを基に関数名を推論する処理
    prompt = f"Suggest a function name for the following code:\n\n{code_snippet}\n\nFunction name:"
    inputs = tokenizer(prompt, return_tensors='pt', max_length=512, truncation=True)
    input_ids = inputs['input_ids']
    attention_mask = inputs['attention_mask']

    output = model.generate(input_ids, attention_mask=attention_mask, max_new_tokens=max_new_tokens, num_return_sequences=1, pad_token_id=tokenizer.pad_token_id)
    generated_name = tokenizer.decode(output[0], skip_special_tokens=True).strip()

    # 事前に定義された関数名リストとの類似度を計算する
    embeddings_known = sentence_model.encode(known_function_names)
    embedding_generated = sentence_model.encode(generated_name)

    # 最も類似した関数名を選択する
    similarity_scores = util.pytorch_cos_sim(embeddings_known, embedding_generated)
    best_match_index = similarity_scores.argmax().item()
    best_match = known_function_names[best_match_index]

    return best_match

# コードから関数の内容を抽出し、関数名を推論して置き換える関数
def extract_and_rename_functions(code):
    # 関数の宣言部分と本体をキャプチャする正規表現
    pattern = re.compile(r'(void\s+)(\w+)(\s*\(.*?\)\s*\{.*?\})', re.DOTALL)

    def replace_function_name(match):
        return match.group(1) + infer_function_name(match.group(0)) + match.group(3)

    # 関数名を推論して置き換える
    new_code = pattern.sub(replace_function_name, code)
    return new_code

# ファイルからコードを読み込む関数
def read_code_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as file:
        return file.read()

# コードをファイルに書き込む関数
def write_code_file(file_path, code, encoding='utf-8'):
    with open(file_path, 'w', encoding=encoding) as file:
        file.write(code)

# コードから関数名を推論して置き換えて出力するメイン関数
def main(file_path):
    # コードを読み込む
    code = read_code_file(file_path)

    # 関数名を推論して置き換える
    new_code = extract_and_rename_functions(code)

    # 新しいコードを出力する
    output_file_path = file_path.replace('.c', '_renamed.c')
    write_code_file(output_file_path, new_code)
    print(f"Renamed functions have been saved to {output_file_path}")

# メイン関数の呼び出し
if __name__ == "__main__":
    source_file_path = 'source.c'
    main(source_file_path)

```
これより得られたC言語のソースコードは以下である。  
```c
#include <stdio.h>


void sort_array(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


void sort_array(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                function1(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main() {
    int arr[100000];  

    
    for (int i = 0; i < 100000; i++) {
        arr[i] = i + 1;
    }

    
    function2(arr, 100000);

    
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```
結果としては、推論された関数名に置き換わったが、要素を交換する関数名についてはswapという名前のほうが適切である。また、main関数、function2関数内の関数呼び出しでの関数名が変更されていない。  
以上より、改善点として  
- 多くの関数名に対応できるようにリストやモデルを拡張する
- 関数呼び出しの際での名前の変更がされていない
- void型の関数にしか対応していない
- 関数の抽出パターンを改良して、他の戻り値や修飾子にも対応させること
- 他の言語にも対応できるようにする
  
# 7/11(Thu)
関数名リストを拡張し、関数の型をint型でもとれるように改良した。
```py
import re
from transformers import AutoModelForCausalLM, AutoTokenizer
from sentence_transformers import SentenceTransformer, util

# 既知の関数名リスト
known_function_names = [
    "swap_elements",
    "sort_array",
    "merge_sort",
    "calculate_average",
    "find_maximum",
    "find_minimum",
    "reverse_string",
    "initialize_array",
    "process_data",
    "compute_sum",
    "update_record",
    "delete_entry",
    "search_item",
    "validate_input",
    "generate_report",
    "connect_to_database",
    "disconnect_from_database",
    "send_email",
    "receive_message",
    "parse_json",
    "encode_base64",
    "decode_base64",
    "compress_file",
    "decompress_file",
    "read_from_file",
    "write_to_file",
    "log_error",
    "log_info",
    "log_debug",
    "calculate_factorial",
    "compute_fibonacci",
    "check_prime",
    "find_gcd",
    "find_lcm",
    "sort_linked_list",
    "traverse_tree",
    "find_in_bst",
    "insert_into_bst",
    "delete_from_bst",
    "sayHello",
    "printNumber",
    "sayGoodbye",
]

# 使用するモデルとトークナイザーの初期化
model_name_or_path = "gpt2"
tokenizer = AutoTokenizer.from_pretrained(model_name_or_path)
model = AutoModelForCausalLM.from_pretrained(model_name_or_path)

# パディングトークンを追加
if tokenizer.pad_token_id is None:
    tokenizer.add_special_tokens({'pad_token': '[PAD]'})
    model.resize_token_embeddings(len(tokenizer))

# SentenceTransformerモデルの初期化
sentence_model = SentenceTransformer('bert-base-nli-mean-tokens')

# 関数名を推論する関数
def infer_function_name(code_snippet, max_new_tokens=10):
    prompt = f"Suggest a function name for the following code snippet:\n\n{code_snippet}\n\nFunction name:"
    inputs = tokenizer(prompt, return_tensors='pt', max_length=512, truncation=True)
    input_ids = inputs['input_ids']
    attention_mask = inputs['attention_mask']

    output = model.generate(input_ids, attention_mask=attention_mask, max_new_tokens=max_new_tokens, num_return_sequences=1, pad_token_id=tokenizer.pad_token_id)
    generated_name = tokenizer.decode(output[0], skip_special_tokens=True).strip()

    embeddings_known = sentence_model.encode(known_function_names)
    embedding_generated = sentence_model.encode(generated_name)

    similarity_scores = util.pytorch_cos_sim(embeddings_known, embedding_generated)
    best_match_index = similarity_scores.argmax().item()
    best_match = known_function_names[best_match_index]

    return best_match

# コードから関数の内容を抽出し、関数名を推論して置き換える関数
def extract_and_rename_functions(code):
    pattern = re.compile(r'((?:\w+\s+)+)(\w+)(\s*\(.*?\)\s*\{.*?\})', re.DOTALL)

    def replace_function_name(match):
        original_name = match.group(2)
        if original_name == 'main':
            return match.group(0)
        function_body = match.group(0)
        new_name = infer_function_name(function_body)
        return match.group(1) + new_name + match.group(3)

    new_code = pattern.sub(replace_function_name, code)
    return new_code

# ファイルからコードを読み込む関数
def read_code_file(file_path, encoding='utf-8'):
    with open(file_path, 'r', encoding=encoding) as file:
        return file.read()

# コードをファイルに書き込む関数
def write_code_file(file_path, code, encoding='utf-8'):
    with open(file_path, 'w', encoding=encoding) as file:
        file.write(code)

# コードから関数名を推論して置き換えて出力するメイン関数
def main(file_path):
    code = read_code_file(file_path)
    new_code = extract_and_rename_functions(code)
    output_file_path = file_path.replace('.c', '_renamed.c')
    write_code_file(output_file_path, new_code)
    print(f"Renamed functions have been saved to {output_file_path}")

if __name__ == "__main__":
    source_file_path = 'source.c'
    main(source_file_path)

```
source.c
```c
#include <stdio.h>


void function1(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


void function2(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                function1(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main() {
    int arr[100000];  

    
    for (int i = 0; i < 100000; i++) {
        arr[i] = i + 1;
    }

   
    function2(arr, 100000);

   
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```
関数名推論すると
```c
#include <stdio.h>


void encode_base64(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}


void encode_base64(int *arr, int size) {
    for (int i = 0; i < size - 1; i++) {
        for (int j = 0; j < size - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                function1(&arr[j], &arr[j + 1]);
            }
        }
    }
}

int main() {
    int arr[100000];  

    
    for (int i = 0; i < 100000; i++) {
        arr[i] = i + 1;
    }

   
    function2(arr, 100000);

   
    for (int i = 0; i < 10; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    return 0;
}
```
source1.c
```c
#include <stdio.h>

#define SIZE 5

int function1(int array[],int size){
    int max =array[0];

    for(int i=1;i<size;i++){
        if(array[i]>max){
            max=array[i];
        }
    }
    return max;
}

int function2(int array[],int size){
    int min=array[0];
    for(int i=1;i<size;i++){
        if(array[i]<min){
            min=array[i];
        }
    }

    return min;
}


int main(){
    int array[SIZE]={7,2,9,4,1};

    int max=function1(array,SIZE);
    int min=function2(array,SIZE);

    printf("配列の最大値: %d\n",max);
    printf("配列の最小値: %d\n",min);

    return 0;
}
```
関数名推論すると
```c
#include <stdio.h>

#define SIZE 5

int initialize_array(int array[],int size){
    int max =array[0];

    for(int i=1;i<size;i++){
        if(array[i]>max){
            max=array[i];
        }
    }
    return max;
}

int initialize_array(int array[],int size){
    int min=array[0];
    for(int i=1;i<size;i++){
        if(array[i]<min){
            min=array[i];
        }
    }

    return min;
}


int main(){
    int array[SIZE]={7,2,9,4,1};

    int max=function1(array,SIZE);
    int min=function2(array,SIZE);

    printf("配列の最大値: %d\n",max);
    printf("配列の最小値: %d\n",min);

    return 0;
}
```
source2.c
```c
#include <stdio.h>

// void 型の関数の定義
void function1() {
    printf("Hello, World!\n");
}

void function2(int num) {
    printf("Number: %d\n", num);
}

void function3() {
    printf("Goodbye!\n");
}

int main() {
    // void 型の関数の呼び出し
    function1();
    function2(42);
    function3();
   
    return 0;
}
```
関数名推論すると
```c
#include <stdio.h>

// void 型の関数の定義
void encode_base64() {
    printf("Hello, World!\n");
}

void encode_base64(int num) {
    printf("Number: %d\n", num);
}

void decode_base64() {
    printf("Goodbye!\n");
}

int main() {
    // void 型の関数の呼び出し
    function1();
    function2(42);
    function3();
   
    return 0;
}
```
以上より、改善点として  
- 多くの関数名に対応できるようにモデルを拡張する
- 関数呼び出しの際での名前の変更がされていない
- 関数の抽出パターンを改良して、他の戻り値や修飾子にも対応させること
- 他の言語にも対応できるようにする

```c
#include <stdio.h>

#define SIZE 5

int function1(int array[],int size){
    int max =array[0];

    for(int i=1;i<size;i++){
        if(array[i]>max){
            max=array[i];
        }
    }
    return max;
}

int function2(int array[],int size){
    int min=array[0];
    for(int i=1;i<size;i++){
        if(array[i]<min){
            min=array[i];
        }
    }

    return min;
}


int main(){
    int array[SIZE]={7,2,9,4,1};

    int max=function1(array,SIZE);
    int min=function2(array,SIZE);

    printf("配列の最大値: %d\n",max);
    printf("配列の最小値: %d\n",min);

    return 0;
}
```
以上をchatgptに投げて、シンボル名を置き換えて貰った。
```c
#include <stdio.h>

#define ARRAY_SIZE 5  // 配列のサイズを定義する定数

// find_max: 配列の最大値を見つける関数
int find_max(int array[], int size){
    int max_value = array[0];  // 配列の最初の要素を最大値として初期化

    for(int i = 1; i < size; i++){  // 配列の残りの要素をチェック
        if(array[i] > max_value){
            max_value = array[i];  // より大きい値が見つかった場合、最大値を更新
        }
    }
    return max_value;  // 最大値を返す
}

// find_min: 配列の最小値を見つける関数
int find_min(int array[], int size){
    int min_value = array[0];  // 配列の最初の要素を最小値として初期化
    for(int i = 1; i < size; i++){  // 配列の残りの要素をチェック
        if(array[i] < min_value){
            min_value = array[i];  // より小さい値が見つかった場合、最小値を更新
        }
    }

    return min_value;  // 最小値を返す
}

int main(){
    int numbers[ARRAY_SIZE] = {7, 2, 9, 4, 1};  // 配列の初期化

    int max_value = find_max(numbers, ARRAY_SIZE);  // 配列の最大値を見つける
    int min_value = find_min(numbers, ARRAY_SIZE);  // 配列の最小値を見つける

    printf("配列の最大値: %d\n", max_value);  // 最大値を表示
    printf("配列の最小値: %d\n", min_value);  // 最小値を表示

    return 0;
}
```
これによって、人間にとってわかりやすいシンボル名になった。

# 7/17(Wed)
もともとのCコード
```c
#include <stdio.h>

int my_sum(int* ,int);

int main(){
	int ary[5] = {1,2,3,4,5};
	int sum = 0;
	int i;

	sum = my_sum(ary,sizeof(ary) / sizeof(int));

	for(i=0;i<5;i++){
		printf("%d ",ary[i]);
	}

	printf("\n");

	printf("sum = %d\n",sum);	

	return 0;
}

int my_sum(int* ary,int size){
	int sum = 0;
	int i;
	
	for(i=0;i<size;i++){
		sum += *(ary + i);
	}

	return sum;
}
```
デコンパイルされたmy_sum関数
```c
int my_sum(long param_1,int param_2)

{
  int local_10;
  int local_c;
  
  local_10 = 0;
  for (local_c = 0; local_c < param_2; local_c = local_c + 1) {
    local_10 = local_10 + *(int *)(param_1 + (long)local_c * 4);
  }
  return local_10;
}
```
main関数が以下
```c
undefined8 main(void)

{
  uint uVar1;
  long in_FS_OFFSET;
  int local_30;
  uint local_28 [4];
  undefined4 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28[0] = 1;
  local_28[1] = 2;
  local_28[2] = 3;
  local_28[3] = 4;
  local_18 = 5;
  uVar1 = my_sum(local_28,5);
  for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
    printf("%d ",(ulong)local_28[local_30]);
  }
  putchar(10);
  printf("sum = %d\n",(ulong)uVar1);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
この以上の２つの関数をAIに食わせてみる。my_sum関数は以下の通りとなった。
```c
int my_sum(long param_1, int param_2) {
    int sum = 0;  // sumの初期値を0に設定

    // 配列の各要素を足し合わせるループ
    for (int i = 0; i < param_2; i++) {
        sum += *(int *)(param_1 + (long)i * 4);  // 配列のi番目の要素を足す
    }

    return sum;  // 合計値を返す
}
```
main関数を食わせると人間が見やすいコード全体を吐き出してくれた。
```c
#include <stdio.h>
#include <stdint.h>

uint32_t my_sum(uint32_t arr[], int length) {
    uint32_t sum = 0;
    for (int i = 0; i < length; i++) {
        sum += arr[i];
    }
    return sum;
}

int main(void) {
    uint32_t array[] = {1, 2, 3, 4, 5};
    int length = sizeof(array) / sizeof(array[0]);

    uint32_t sum = my_sum(array, length);

    for (int i = 0; i < length; i++) {
        printf("%d ", array[i]);
    }
    putchar('\n');

    printf("sum = %d\n", sum);

    return 0;
}
```
デコンパイルされたCコードからの改善点としては
- 'local_28'は'array'に変更されている。
- 'local_18'は不要であるため、削除されている。
- 'local_10'はスタック保護機構に関連する変数で、簡単化のため削除されている。
- ループもより簡素化されている。
- 不要なローカル変数が削除されている。

実行結果も右の通り期待通りの出力をした。
![Screenshot from 2024-07-17 16-43-45](https://github.com/user-attachments/assets/a9a078f6-4e69-4c9c-8760-2d224ce603b2)  
__________________________________________________________________________________________________________________________  

## データ分析から新商品を考える
KaggleにあるECのデータセットを用いて売れている商品やよく利用している層を分析、これを土台とし新商品の品目やターゲットを設定しターゲットからのフィードバックがサイトのレビューでどの数値に該当するか予測するモデルの構築を行う。  
- データの読み込み
```py
df = pd.read_csv("Womens Clothing E-Commerce Reviews.csv")
df.head()
```
<実行結果>  
|index|Unnamed: 0|Clothing ID|Age|Title|Review Text|Rating|Recommended IND|Positive Feedback Count|Division Name|Department Name|Class Name|
|---|---|---|---|---|---|---|---|---|---|---|---|
|0|0|767|33|NaN|Absolutely wonderful - silky and sexy and comfortable|4|1|0|Initmates|Intimate|Intimates|
|1|1|1080|34|NaN|Love this dress\!  it's sooo pretty\.  i happened to find it in a store, and i'm glad i did bc i never would have ordered it online bc it's petite\.  i bought a petite and am 5'8"\.  i love the length on me- hits just a little below the knee\.  would definitely be a true midi on someone who is truly petite\.|5|1|4|General|Dresses|Dresses|
|2|2|1077|60|Some major design flaws|I had such high hopes for this dress and really wanted it to work for me\. i initially ordered the petite small \(my usual size\) but i found this to be outrageously small\. so small in fact that i could not zip it up\! i reordered it in petite medium, which was just ok\. overall, the top half was comfortable and fit nicely, but the bottom half had a very tight under layer and several somewhat cheap \(net\) over layers\. imo, a major design flaw was the net over layer sewn directly into the zipper - it c|3|0|0|General|Dresses|Dresses|
|3|3|1049|50|My favorite buy\!|I love, love, love this jumpsuit\. it's fun, flirty, and fabulous\! every time i wear it, i get nothing but great compliments\!|5|1|0|General Petite|Bottoms|Pants|
|4|4|847|47|Flattering shirt|This shirt is very flattering to all due to the adjustable front tie\. it is the perfect length to wear with leggings and it is sleeveless so it pairs well with any cardigan\. love this shirt\!\!\!|5|1|6|General|Tops|Blouses|  

今回の分析やモデル作成で使うのはAge,Review Text,Rating,Division Name,Department Name,Class Nameであるため、関係ないものはカットする。そのあと、要約統計量と欠損値の有無を確認する。
```py
df.describe()
```
|index|Age|Rating|
|---|---|---|
|count|23486\.0|23486\.0|
|mean|43\.198543813335604|4\.196031678446734|
|std|12\.279543615591493|1\.1100307198243897|
|min|18\.0|1\.0|
|25%|34\.0|4\.0|
|50%|41\.0|5\.0|
|75%|52\.0|5\.0|
|max|99\.0|5\.0|  

```py
df.isnull().sum()
```
```
Age                  0
Review Text        845
Rating               0
Division Name       14
Department Name     14
Class Name          14
dtype: int64
```
全体に対して欠損のあるデータは多くないためカット、残ったもので分析していく。  
Class Nameが最も品目を具体的に示しているのでこれを分析の対象とする。  
今度はお客さんの年齢層を見る。要約統計量をもう一度見ていく。
```py
df["Age"].describe()
```
```
count    22628.000000
mean        43.282880
std         12.328176
min         18.000000
25%         34.000000
50%         41.000000
75%         52.000000
max         99.000000
Name: Age, dtype: float64
```
全体的に40代前後に固まっているように見えるがこれだけでは曖昧である。 
今回は2021年を起点に計算した年齢層で分割していく。また、アメリカにおける各世代とその呼び名を参考にする。
```py
year = 2021
#　分割の粒度
generation_bins = [0, 2021 - 2004, 2021 - 1979, 2021 - 1964, 2021 - 1944, 2021 - 1924, 2021 - 1899]
generation_names = ['Generation Z', 'Millennials', 'Generation X', 'Baby Boomer', 'Silent Generation', 'G.I. Generation']

# ビン分割の実施
generation_cut_data = pd.cut(df.Age, generation_bins, labels = generation_names)
df["Generation"] = generation_cut_data
```
参考情報としてアメリカの世代区分は以下のようになっている。
- 1900年 – 1925年生まれ G.I. Generation (G.I.世代)

- 1925 – 1945年生まれ Silent Generation (沈黙の世代)

- 1945 – 1965年生まれ Baby Boomer (ベビーブーム時に生まれた世代)

- 1965 – 1980年生まれ Generation X (X世代)

- 1980 – 2005年生まれ Millennials (ミレニアルズ)

- 2005年以後 Generation Z (Z世代)
分けた世代で一番多いのはどれか、そしてその世代が最も購入するClass Nameを見ていく。
```py
df["Generation"].value_counts()
```
```
Millennials          12103
Generation X          7216
Baby Boomer           3171
Silent Generation      136
G.I. Generation          2
Generation Z             0
Name: Generation, dtype: int64
```
次にClass Nameを見ていく。
```py
df[df["Generation"] =="Millennials"]["Class Name"].value_counts()
```
```
Dresses           3518
Knits             2406
Blouses           1473
Pants              691
Sweaters           663
Jeans              600
Fine gauge         498
Skirts             496
Lounge             370
Jackets            350
Swim               233
Shorts             188
Outerwear          168
Sleep              115
Legwear             99
Intimates           98
Layering            77
Trend               58
Chemises             1
Casual bottoms       1
Name: Class Name, dtype: int64
```
1980年から2005年の間に生まれた世代、Millennialsの利用が多くて、注文の多くがDressesであることがわかる。現在ではカジュアルな服装で通勤しても良い会社が多く見られるため、今後の需要に響く可能性がある。代案として２番目に高いKnitsが候補に上がるもののこれが具体的に何を指すかわかりにくいことが問題点である。３番目に位置するBlousesであれば普段着としてもオンラインで会議などで着る時でも使えるためこれを新製品としていく。  


最後のステップとして試作品ができたことを想定、モニタリングをした人の評価が実際のサイト上だとどのレビューに相当するかを予測するモデルを作る。
```py
review["Rating"].value_counts()
```
```
5    746
4    334
3    217
2    133
1     43
Name: Rating, dtype: int64
```
ミレニアル世代がBlousesに対して出したレビューを見ると約半数が最大の５をつけていることがわかる。ただ、もともとのデータ数が多くはないので５つに分けるとますます少なくなり正確かどうかで怪しくなってしまう。  
まず全データの文章をレートの数字ごとのリストに分け、単語に切り分けて格納する。だから、レビューが5なのをbest,3と4をbetter,1と2をbadとしていく。
```py
bad = []
better = []
best = []

for text, rating in zip(review['Review Text'], review['Rating']):
    line = text.split(" ")
    dic = {}
    if rating == 1 or 2:
        for word in line:
            dic[word] = True
        ireru = (dic, "Bad")
        bad.append(ireru)
    elif rating == 3 or 4:
        for word in line:
            dic[word] = True
        ireru = (dic, "Better")
        better.append(ireru) 
    else:
        for word in line:
            dic[word] = True
        ireru = (dic, "Best")
        best.append(ireru)
```
仕分けができたためそれぞれから学習用のデータとテスト用のデータで8:2に分ける。  
分けたものそれぞれの学習用テスト用で合わせたものを全体のものとする。
```py
threshold = 0.8
num_bad = int(threshold * len(bad))
num_better = int(threshold * len(better))
num_best = int(threshold * len(best))

features_train = bad[:num_bad] + better[:num_better] + best[:num_best]
features_test = bad[num_bad:] + better[num_better:] + best[num_best:]
print("Number of training datapoints:", len(features_train))
print("Number of test datapoints:", len(features_test))
```
```
Number of training datapoints: 1178
Number of test datapoints: 295
```
そして学習させたものでテスト用データに数字の判定をさせたところ精度は悪くないようである。
```py
classifier = NaiveBayesClassifier.train(features_train)
print('Accuracy of the classifier:', nltk_accuracy(classifier, features_test))
```
```
Accuracy of the classifier: 1.0
```
学習させた中でどういったワードが予測された数字を左右されたのかをみる。
```py
N = 10
print('Top ' + str(N) + ' most informative words:')
for i, item in enumerate(classifier.most_informative_features()[:N]):
    print(str(i+1) + '. ' + item[0]) 
```
```
Top 10 most informative words:
1. pieces
2. oxfords
3. adore
4. bra
5. shoe
6. 16,
7. has.
8. double-lined,
9. blonde
10. area
```
感情的な単語よりも具体性のある単語が並んでいるようである。
```py
def extract_features(words):
    return dict([(word, True) for word in words])
#先程の大量のレビューテキストと同様単語に分けていく

input_review = input()
print("Clothes review predictions:")

print("\nReview:",input_review)
features = extract_features(input_review.split())
probabilities = classifier.prob_classify(features)
predicted_sentiment = probabilities.max()
print("Predicted sentiment:", predicted_sentiment)
print("Probability:", round(probabilities.prob(predicted_sentiment), 2))
#入力した文章がどの数字にあたる可能性が一番高いかを計算し出力させる
```
例えば、ここで"I cannnot believe how terrible is it!"と入力する。
```py
Clothes review predictions:
Review: I cannnot believe how terrible is it!
Predicted sentiment: Bad
Probability: 1.0
```
計算上ほぼ間違いなく低い評価だと言っていることがわかった。

#  7/18(Thu)
より煩雑なCコードで試してみる。もともとのCコード
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 定数定義
#define MAX_RECORDS 100
#define NAME_LENGTH 50
#define MAX_BUFFER 1024

// 構造体定義
typedef struct {
    int id;
    char name[NAME_LENGTH];
    int age;
} Record;

// プロトタイプ宣言
void addRecord(Record records[], int* recordCount);
void deleteRecord(Record records[], int* recordCount, int id);
void searchRecord(Record records[], int recordCount, int id);
void displayRecords(Record records[], int recordCount);
int getMenuChoice();

// メイン関数
int main() {
    Record records[MAX_RECORDS];
    int recordCount = 0;
    int choice;

    do {
        choice = getMenuChoice();
        switch (choice) {
            case 1:
                addRecord(records, &recordCount);
                break;
            case 2:
                printf("削除するレコードのIDを入力してください: ");
                int deleteId;
                scanf("%d", &deleteId);
                deleteRecord(records, &recordCount, deleteId);
                break;
            case 3:
                printf("検索するレコードのIDを入力してください: ");
                int searchId;
                scanf("%d", &searchId);
                searchRecord(records, recordCount, searchId);
                break;
            case 4:
                displayRecords(records, recordCount);
                break;
            case 5:
                printf("プログラムを終了します。\n");
                break;
            default:
                printf("無効な選択です。再試行してください。\n");
                break;
        }
    } while (choice != 5);

    return 0;
}

// メニュー選択を取得する関数
int getMenuChoice() {
    int choice;
    printf("\nメニュー:\n");
    printf("1. レコードを追加\n");
    printf("2. レコードを削除\n");
    printf("3. レコードを検索\n");
    printf("4. レコードを表示\n");
    printf("5. 終了\n");
    printf("選択肢を入力してください: ");
    scanf("%d", &choice);
    return choice;
}

// レコードを追加する関数
void addRecord(Record records[], int* recordCount) {
    if (*recordCount >= MAX_RECORDS) {
        printf("レコードの数が上限に達しました。\n");
        return;
    }

    Record newRecord;
    newRecord.id = *recordCount + 1;
    printf("名前を入力してください: ");
    scanf("%s", newRecord.name);
    printf("年齢を入力してください: ");
    scanf("%d", &newRecord.age);

    records[*recordCount] = newRecord;
    (*recordCount)++;
    printf("レコードが追加されました。\n");
}

// レコードを削除する関数
void deleteRecord(Record records[], int* recordCount, int id) {
    int found = 0;
    for (int i = 0; i < *recordCount; i++) {
        if (records[i].id == id) {
            for (int j = i; j < *recordCount - 1; j++) {
                records[j] = records[j + 1];
            }
            (*recordCount)--;
            found = 1;
            printf("レコードが削除されました。\n");
            break;
        }
    }
    if (!found) {
        printf("指定されたIDのレコードが見つかりませんでした。\n");
    }
}

// レコードを検索する関数
void searchRecord(Record records[], int recordCount, int id) {
    for (int i = 0; i < recordCount; i++) {
        if (records[i].id == id) {
            printf("ID: %d, 名前: %s, 年齢: %d\n", records[i].id, records[i].name, records[i].age);
            return;
        }
    }
    printf("指定されたIDのレコードが見つかりませんでした。\n");
}

// レコードを表示する関数
void displayRecords(Record records[], int recordCount) {
    if (recordCount == 0) {
        printf("表示するレコードがありません。\n");
        return;
    }

    for (int i = 0; i < recordCount; i++) {
        printf("ID: %d, 名前: %s, 年齢: %d\n", records[i].id, records[i].name, records[i].age);
    }
}
```
デコンパイルされたmain関数
```c

undefined8 main(void)

{
  long in_FS_OFFSET;
  undefined4 local_1794;
  undefined4 local_1790;
  int local_178c;
  undefined local_1788 [6008];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_1794 = 0;
  do {
    local_178c = getMenuChoice();
    switch(local_178c) {
    default:
      puts(&DAT_001020b0);
      break;
    case 1:
      addRecord(local_1788,&local_1794);
      break;
    case 2:
      printf(&DAT_00102008);
      __isoc99_scanf(&DAT_00102043,&local_1790);
      deleteRecord(local_1788,&local_1794,local_1790);
      break;
    case 3:
      printf(&DAT_00102048);
      __isoc99_scanf(&DAT_00102043,&local_1790);
      searchRecord(local_1788,local_1794,local_1790);
      break;
    case 4:
      displayRecords(local_1788,local_1794);
      break;
    case 5:
      puts(&DAT_00102088);
    }
  } while (local_178c != 5);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
このmain関数をAIに投げて人間が読みやすいコードに変えてもらうと、
```c
#include <stdio.h>

// Function prototypes
int getMenuChoice();
void addRecord(char *records, int *recordCount);
void deleteRecord(char *records, int *recordCount, int recordId);
void searchRecord(char *records, int recordCount, int recordId);
void displayRecords(char *records, int recordCount);

int main(void) {
    int choice;
    int recordCount = 0;
    int recordId;
    char records[6008];

    while (1) {
        choice = getMenuChoice();
        
        switch (choice) {
            case 1:
                addRecord(records, &recordCount);
                break;
            case 2:
                printf("Enter the ID of the record to delete: ");
                scanf("%d", &recordId);
                deleteRecord(records, &recordCount, recordId);
                break;
            case 3:
                printf("Enter the ID of the record to search: ");
                scanf("%d", &recordId);
                searchRecord(records, recordCount, recordId);
                break;
            case 4:
                displayRecords(records, recordCount);
                break;
            case 5:
                puts("Exiting...");
                return 0;
            default:
                puts("Invalid choice. Please try again.");
                break;
        }
    }

    return 0;
}

int getMenuChoice() {
    int choice;
    printf("Menu:\n");
    printf("1. Add Record\n");
    printf("2. Delete Record\n");
    printf("3. Search Record\n");
    printf("4. Display Records\n");
    printf("5. Exit\n");
    printf("Enter your choice: ");
    scanf("%d", &choice);
    return choice;
}

void addRecord(char *records, int *recordCount) {
    // Implementation of adding a record
    printf("Adding a record...\n");
    (*recordCount)++;
}

void deleteRecord(char *records, int *recordCount, int recordId) {
    // Implementation of deleting a record
    printf("Deleting record with ID %d...\n", recordId);
    (*recordCount)--;
}

void searchRecord(char *records, int recordCount, int recordId) {
    // Implementation of searching a record
    printf("Searching for record with ID %d...\n", recordId);
}

void displayRecords(char *records, int recordCount) {
    // Implementation of displaying records
    printf("Displaying %d records...\n", recordCount);
}
```
以上のようになリファクタリングされており、とても見やすいものになっている。しかしながら、欲しい仕様にはならなかった。レコードを操作する関数に関して、適切な処理が行われていない。  
AIには逆アセンブリされたmain関数のみを入力としたため、期待通りの出力ではなかったと考える。他の関数、構造体の逆アセンブリされたものを入力とすれば、より完成度の高いCコードを出力すると思われる。  
構造体は定義されていないため、他の関数とmain関数を入力としてAIに投げる。
```c
#include <stdio.h>
#include <stdbool.h>

void addRecord(long param_1, int *param_2) {
    int index;
    long in_FS_OFFSET;
    undefined4 recordIndex;
    undefined8 recordData[7];
    undefined4 extraData[4];
    long local_20;

    local_20 = *(long *)(in_FS_OFFSET + 0x28);

    if (*param_2 < 100) {
        index = *param_2;
        printf("Enter the index and record data: ");
        __isoc99_scanf("%d", &recordIndex);
        printf("Enter additional data: ");
        __isoc99_scanf("%d", extraData);
        
        undefined8 *recordPtr = (undefined8 *)(param_1 + (long)*param_2 * 0x3c);
        *recordPtr = CONCAT44(recordIndex, index + 1);
        for (int i = 0; i < 7; i++) {
            recordPtr[i + 1] = recordData[i];
        }
        *(undefined4 *)(recordPtr + 7) = extraData[0];
        *param_2 += 1;
        puts("Record added successfully.");
    } else {
        puts("Maximum number of records reached.");
    }

    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
        __stack_chk_fail();
    }
}

void deleteRecord(long param_1, int *param_2, int param_3) {
    bool recordFound = false;
    int recordIndex, recordCount;

    for (recordIndex = 0; recordIndex < *param_2; recordIndex++) {
        if (param_3 == *(int *)(param_1 + (long)recordIndex * 0x3c)) {
            break;
        }
    }

    if (recordIndex < *param_2) {
        for (recordCount = recordIndex; recordCount < *param_2 - 1; recordCount++) {
            undefined8 *nextRecordPtr = (undefined8 *)((long)(recordCount + 1) * 0x3c + param_1);
            undefined8 *currentRecordPtr = (undefined8 *)(param_1 + (long)recordCount * 0x3c);
            
            for (int i = 0; i < 7; i++) {
                currentRecordPtr[i] = nextRecordPtr[i];
            }
        }
        *param_2 -= 1;
        recordFound = true;
        puts("Record deleted successfully.");
    }

    if (!recordFound) {
        puts("Record not found.");
    }
}

void displayRecords(long param_1, int param_2) {
    if (param_2 == 0) {
        puts("No records to display.");
    } else {
        for (int i = 0; i < param_2; i++) {
            printf("Record %d: %s %d\n",
                   *(uint *)(param_1 + (long)i * 0x3c),
                   (char *)(param_1 + (long)i * 0x3c + 4),
                   *(uint *)(param_1 + (long)i * 0x3c + 0x38));
        }
    }
}

undefined4 getMenuChoice(void) {
    long in_FS_OFFSET;
    undefined4 choice;
    long local_10;

    local_10 = *(long *)(in_FS_OFFSET + 0x28);

    puts("1. Add record");
    puts("2. Delete record");
    puts("3. Search record");
    puts("4. Display records");
    puts("5. Exit");
    printf("Enter your choice: ");
    __isoc99_scanf("%d", &choice);

    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
        __stack_chk_fail();
    }
    return choice;
}

undefined8 main(void) {
    long in_FS_OFFSET;
    undefined4 recordIndex;
    int menuChoice;
    int recordCount = 0;
    char records[6008];
    long local_10;

    local_10 = *(long *)(in_FS_OFFSET + 0x28);

    do {
        menuChoice = getMenuChoice();
        switch (menuChoice) {
            case 1:
                addRecord((long)records, &recordCount);
                break;
            case 2:
                printf("Enter the record index to delete: ");
                __isoc99_scanf("%d", &recordIndex);
                deleteRecord((long)records, &recordCount, recordIndex);
                break;
            case 3:
                printf("Enter the record index to search: ");
                __isoc99_scanf("%d", &recordIndex);
                searchRecord((long)records, recordCount, recordIndex);
                break;
            case 4:
                displayRecords((long)records, recordCount);
                break;
            case 5:
                puts("Exiting...");
                break;
            default:
                puts("Invalid choice. Please try again.");
        }
    } while (menuChoice != 5);

    if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
        __stack_chk_fail();
    }

    return 0;
}

void searchRecord(long param_1, int param_2, int param_3) {
    int recordIndex;

    for (recordIndex = 0; recordIndex < param_2; recordIndex++) {
        if (param_3 == *(int *)(param_1 + (long)recordIndex * 0x3c)) {
            printf("Record %d: %s %d\n",
                   *(uint *)(param_1 + (long)recordIndex * 0x3c),
                   (char *)(param_1 + (long)recordIndex * 0x3c + 4),
                   *(uint *)(param_1 + (long)recordIndex * 0x3c + 0x38));
            return;
        }
    }
    puts("Record not found.");
}
```
ところどころシンタックスエラーになることがわかる。構造体を定義しても同じような結末である。

# 7/22(Mon)
シンボル情報をストリッピングした場合  
main関数
```c

undefined8 FUN_00101189(void)

{
  uint uVar1;
  long in_FS_OFFSET;
  int local_30;
  uint local_28 [4];
  undefined4 local_18;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  local_28[0] = 1;
  local_28[1] = 2;
  local_28[2] = 3;
  local_28[3] = 4;
  local_18 = 5;
  uVar1 = FUN_00101252(local_28,5);
  for (local_30 = 0; local_30 < 5; local_30 = local_30 + 1) {
    printf("%d ",(ulong)local_28[local_30]);
  }
  putchar(10);
  printf("sum = %d\n",(ulong)uVar1);
  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return 0;
}
```
my_sum関数
```c

int FUN_00101252(long param_1,int param_2)

{
  int local_10;
  int local_c;
  
  local_10 = 0;
  for (local_c = 0; local_c < param_2; local_c = local_c + 1) {
    local_10 = local_10 + *(int *)(param_1 + (long)local_c * 4);
  }
  return local_10;
}
```
このmain関数をopenAI(3.5)に食わせてみると、関数内の理解は間違いなく行われた。  
さらに、リファクタリングを行うと、
```c
#include <stdio.h>

uint calculate_sum(uint *array, int size);

void print_array(uint *array, int size);

void check_stack_canary(long initial_canary);

undefined8 function_example(void) {
    uint sum;
    long initial_canary;
    int i;
    uint values[4];
    long stack_canary;

    // スタックカナリアの設定
    initial_canary = *(long *)(__builtin_frame_address(0) + 0x28);

    // 配列の初期化
    values[0] = 1;
    values[1] = 2;
    values[2] = 3;
    values[3] = 4;
    
    // 配列の合計を計算
    sum = calculate_sum(values, 4);

    // 配列の内容を表示
    print_array(values, 4);

    // 合計値を表示
    printf("sum = %d\n", sum);

    // スタックカナリアのチェック
    check_stack_canary(initial_canary);

    return 0;
}

uint calculate_sum(uint *array, int size) {
    uint sum = 0;
    for (int i = 0; i < size; i++) {
        sum += array[i];
    }
    return sum;
}

void print_array(uint *array, int size) {
    for (int i = 0; i < size; i++) {
        printf("%d ", array[i]);
    }
    putchar('\n');
}

void check_stack_canary(long initial_canary) {
    if (initial_canary != *(long *)(__builtin_frame_address(0) + 0x28)) {
        // スタックオーバーフローが発生した場合
        __stack_chk_fail();
    }
}
```
大幅にわかりやすいコードになったと思われる。  
問題点を挙げるとすれば
- 配列の最後の要素がなくなってしまった。
- 'undefined8 function_example(void)'という関数が宣言されているが、型が適切ではない。
- 'uint'型が未定義なため、'stdint.h'をインクルードする必要がある。

# 7/24(Wed)
少し複雑なCコードで試してみる。以下は、ファイルの読み書き、メモリ管理、文字列操作などを行っている。
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024

void process_line(char *line) {
    // ここで各行を処理します（例：大文字に変換）
    for (int i = 0; line[i] != '\0'; i++) {
        if (line[i] >= 'a' && line[i] <= 'z') {
            line[i] = line[i] - 'a' + 'A';
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <input_file> <output_file>\n", argv[0]);
        return 1;
    }

    FILE *input_file = fopen(argv[1], "r");
    if (input_file == NULL) {
        perror("Error opening input file");
        return 1;
    }

    FILE *output_file = fopen(argv[2], "w");
    if (output_file == NULL) {
        perror("Error opening output file");
        fclose(input_file);
        return 1;
    }

    char *line = (char *)malloc(MAX_LINE_LENGTH);
    if (line == NULL) {
        perror("Memory allocation failed");
        fclose(input_file);
        fclose(output_file);
        return 1;
    }

    while (fgets(line, MAX_LINE_LENGTH, input_file)) {
        process_line(line);
        fputs(line, output_file);
    }

    free(line);
    fclose(input_file);
    fclose(output_file);

    printf("Processing complete. Output written to %s\n", argv[2]);
    return 0;
}
```
上のコードをデコンパイルして得られるmain関数は以下の通りである。
```c

undefined8 FUN_001012c6(int param_1,undefined8 *param_2)

{
  undefined8 uVar1;
  FILE *__stream;
  FILE *__stream_00;
  char *__s;
  char *pcVar2;
  
  if (param_1 < 3) {
    fprintf(stderr,"Usage: %s <input_file> <output_file>\n",*param_2);
    uVar1 = 1;
  }
  else {
    __stream = fopen((char *)param_2[1],"r");
    if (__stream == (FILE *)0x0) {
      perror("Error opening input file");
      uVar1 = 1;
    }
    else {
      __stream_00 = fopen((char *)param_2[2],"w");
      if (__stream_00 == (FILE *)0x0) {
        perror("Error opening output file");
        fclose(__stream);
        uVar1 = 1;
      }
      else {
        __s = (char *)malloc(0x400);
        if (__s == (char *)0x0) {
          perror("Memory allocation failed");
          fclose(__stream);
          fclose(__stream_00);
          uVar1 = 1;
        }
        else {
          while( true ) {
            pcVar2 = fgets(__s,0x400,__stream);
            if (pcVar2 == (char *)0x0) break;
            FUN_00101249(__s);
            fputs(__s,__stream_00);
          }
          free(__s);
          fclose(__stream);
          fclose(__stream_00);
          printf("Processing complete. Output written to %s\n",param_2[2]);
          uVar1 = 0;
        }
      }
    }
  }
  return uVar1;
}
```
これをAIに食わせると関数内の理解はほぼあたっていた。さらにリファクタリングしてもらうと、
```c
#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE 1024

void process_line(char *line);
void cleanup(FILE *input, FILE *output, char *buffer);

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <input_file> <output_file>\n", argv[0]);
        return 1;
    }

    FILE *input = fopen(argv[1], "r");
    if (input == NULL) {
        perror("Error opening input file");
        return 1;
    }

    FILE *output = fopen(argv[2], "w");
    if (output == NULL) {
        perror("Error opening output file");
        fclose(input);
        return 1;
    }

    char *buffer = (char *)malloc(BUFFER_SIZE);
    if (buffer == NULL) {
        perror("Memory allocation failed");
        cleanup(input, output, buffer);
        return 1;
    }

    while (fgets(buffer, BUFFER_SIZE, input) != NULL) {
        process_line(buffer);
        fputs(buffer, output);
    }

    printf("Processing complete. Output written to %s\n", argv[2]);
    cleanup(input, output, buffer);
    return 0;
}

void process_line(char *line) {
    // Implement the processing logic here
}

void cleanup(FILE *input, FILE *output, char *buffer) {
    if (input) fclose(input);
    if (output) fclose(output);
    if (buffer) free(buffer);
}
```

# 7/28(Sun)
アセンブリ言語をOpenAIに  
配列の和を計算してくれるCコードを使用した。以下はそのアセンブリ言語である。
```s
section .data
    ary db 1, 2, 3, 4, 5
    sum db 0
    format db "%d ", 0
    format_sum db "sum = %d", 10, 0

section .bss
    i resb 1
    size resb 4

section .text
    extern printf
    global main

main:
    ; Initialize size
    mov eax, 5
    mov [size], eax

    ; Call my_sum
    lea rdi, [ary]
    mov rsi, [size]
    call my_sum
    mov [sum], eax

    ; Print array
    mov ecx, 5
    mov rbx, ary

print_loop:
    cmp ecx, 0
    je print_sum
    push rbx
    movzx rdi, byte [rbx]
    push rdi
    lea rdi, [format]
    call printf
    add rsp, 8
    pop rbx
    inc rbx
    dec ecx
    jmp print_loop

print_sum:
    ; Print sum
    mov eax, [sum]
    push eax
    lea rdi, [format_sum]
    call printf
    add rsp, 8

    ; Return 0
    mov eax, 0
    ret

my_sum:
    ; Function parameters: rdi = ary, rsi = size
    xor rax, rax          ; sum = 0
    xor rcx, rcx          ; i = 0

sum_loop:
    cmp rcx, rsi          ; if (i < size)
    jge end_sum
    movzx rdx, byte [rdi + rcx] ; sum += *(ary + i)
    add rax, rdx
    inc rcx
    jmp sum_loop

end_sum:
    ret

```
このコードをCコードに直してもらうと
```c
#include <stdio.h>

// 配列とフォーマット文字列をグローバル変数として定義
unsigned char ary[] = {1, 2, 3, 4, 5};
unsigned char sum = 0;
const char *format = "%d ";
const char *format_sum = "sum = %d\n";

// 関数プロトタイプの宣言
unsigned char my_sum(unsigned char *ary, unsigned int size);

int main() {
    // 配列のサイズを設定
    unsigned int size = 5;

    // my_sum関数を呼び出してsumを計算
    sum = my_sum(ary, size);

    // 配列の各要素を出力
    for (int i = 0; i < size; i++) {
        printf(format, ary[i]);
    }

    // 合計値を出力
    printf(format_sum, sum);

    // プログラムの終了
    return 0;
}

unsigned char my_sum(unsigned char *ary, unsigned int size) {
    unsigned char sum = 0;

    // 配列の要素を合計
    for (unsigned int i = 0; i < size; i++) {
        sum += ary[i];
    }

    return sum;
}
```
期待されたコードがはかれたように思われる。
