# 8/1(Thu)
花火を打ち上げるアプリケーションを作った。  
[fireworks](fireworks)

**研究**  
16進バイナリではOpenAIによってCコードにすることはできなかった。アセンブリ言語であれば、ｃコードに直せることができた。  
このことから、バイナリデータを用いてファインチューニングを行う。その際にバイナリデータを適切に変換するためにllvmツールを用いる
と効果的になる。

# 8/28(Wed)
OpenAIに多くの機械語コードとCコードのセットを投下した。そして以下のCコードの機械語コード（16進）を投下する。  
```c
int add(int a, int b) {
    return a + b;
}
```

```
   0:	f3 0f 1e fa          	 
   4:	55                   	
   5:	48 89 e5             	
   8:	89 7d fc             	
   b:	89 75 f8             	
   e:	8b 55 fc             	
  11:	8b 45 f8             	
  14:	01 d0                	
  16:	5d                   	
  17:	c3                   	
```
出力されたCコードは以下である。  
```c
void addToTop(Stack *s, int value) {
    s->items[s->top] += value;
}
```
両者は加算することに関しては同じであるが、動作が違う。  
- addToTop: スタックのデータを操作します。スタックの状態を変更し、スタック内のデータに対して加算操作を行う。
- add: 2つの整数値を加算し、その結果を返します。外部の状態を変更することはない。

次に上の加算を学んだあとに減算についての機械語コードを与えてみた。
```c
int subtract(int a, int b) {
    return a - b;
}
```
```
  18:	f3 0f 1e fa          	
  1c:	55                   	
  1d:	48 89 e5             	
  20:	89 7d fc             	
  23:	89 75 f8             	
  26:	8b 45 fc             	
  29:	2b 45 f8             	
  2c:	5d                   	
  2d:	c3                   	
```
出力されたCコードは以下である。
```c
int subtract(int a, int b) {
    return a - b;
}
```
入力と同じCコードをはいてくれた。積に関する関数についても正しく出力した。

# 8/30(Fri)
ローカルの言語モデルにファインチューニングしてみる。
- elyza:jp8b
