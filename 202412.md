# 12/2(Mon)
卒論  
タイトル「大規模言語モデルによる逆コンパイル手法についての検討」  
```
1. はじめに
・ 研究の背景
・ 研究目的
・ 研究の意義
・ 論文の構成

2. 大規模言語モデルと逆コンパイル
  2.1. 逆コンパイルの概要
・　逆コンパイルの定義と目的
・　逆コンパイルが必要とされる理由

    2.1.1. 逆コンパイルツール
・現在使用されている代表的な逆コンパイルツール（例：Ghidra, IDA Pro, Binary Ninjaなど）
・各ツールの特徴と利点・欠点

  2.2. 大規模言語モデル
・大規模言語モデルの定義と構造（例えば、Transformerアーキテクチャ）
・訓練方法と大規模データセットの重要性

    2.2.1 GPT-4o
・GPT-4のアーキテクチャと特性
・GPT-4が逆コンパイルにおいて有望な理由

  2.3. 逆コンパイルにおける課題
・現状の大規模言語モデルを使った逆コンパイルの問題点
・特に難しいケース（例：最適化されたバイナリの逆コンパイル、曖昧な命令の解釈）

  2.4. 課題点に対する改善手法
・提案する改善策（例：ファインチューニングの利用、追加の前処理や後処理手法）

3. ファインチューニングによる手法の提案
  3.1. ファインチューニングの概要
・ファインチューニングとは何か
・GPT-4を逆コンパイルタスクに適用する場合の意義

  3.2. データセットの準備
・使用したデータセット（例：バイナリコードからアセンブリコード、アセンブリコードからCコードのペアデータ）
・データセットの前処理方法とその意図

  3.3. バイナリコードからアセンブリコードへの変換
・バイナリコードからアセンブリコードを逆コンパイルするためのファインチューニング手法
・モデルのパフォーマンスとその改善方法

  3.4. アセンブリコードからCコードへの変換
・アセンブリコードをCコードに変換するプロセスとファインチューニング
・課題とその解決策

4. 評価
  4.1. 評価手法
・どのようにしてモデルの性能を評価するか
・使用する指標（例：精度、再現率、F値、計算資源の使用状況）

  4.2. 評価結果
・実際の評価結果とその解析
・他の手法や既存のツールと比較しての優位性
・課題点とその改善案

5. おわりに
・ 結論
   ・ 研究の結果とその意義
   ・提案した手法の効果と可能性

・ 今後の研究課題
   ・さらに改善できる点、次のステップ
```

# 12/3(Tu)
### Linux　ネットワークトラブルについて  
- IPアドレスが割り当てられていない
   > ネットワークインタフェースの自動起動が設定されないことがある。この場合、システム起動時にネットワークインタフェースが有効化されてネットワークに接続し、IPアドレスの割り当てが行われるという一連の動作が実行されない。
   > 例えば、インターフェースデバイスenp0s3にIPアドレスが割り当てられていない場合、NetworkManagerのCLIツールnmcliコマンドで以下のように実行することでネットワークインターフェースを有効にできる。
   > ```
   > sudo nmcli dev connect enp0s3
   > デバイス`enp0s3`が`297c9686-a34f-3734-8931-89fa9b051d30`で正常にアクティベートされました。
   > ```
- 参照するDNSが間違っている
   > DNSによる名前解決が正しく行えない理由はいくつかあるが、一つに参照するDNSが間違えている場合がある。参照しているDNSは/etc/re
   > solv.confの記述で確認ができる。
   > ```
   > cat /etc/resolv.conf
   > #  Geneerated by NetworkManager
   > search xxx.jp
   > nameserver 192.168.11.1
   > ```
   > この環境の場合、IPアドレスはルータのDHCPサーバーからDHCPで自動設定されているため、DNSの参照先もDHCPで自動設定されている。ここが間違っているなら、DHCPサーバーの設定を見直す必要がある。
- pingコマンド
   > ネットワークの問題が発生した場合はとりあえずpingコマンド
   > pingコマンドを打って、目的のサーバまで疎通できるかを確認する。
   > pingが通れば、サーバ間のNWが疎通している＆対向のサーヴァが起動していることを確認できる。
- arpコマンド
   > ゲートウェイまでの疎通が確認できない場合は、arp -a でゲートウェイのMACアドレスが見えてるかを確認する。
- tracerouteコマンド
   > NICを複数持っている場合で、サーバ側にルーティング設定を行っている場合、正しいNICから通信を行おうとしていない場合がある。
   > 正しいNICで通信しようとしているかを確認するためにtracerouteコマンドを用いる。
   > ```
   > [root@localhost ~]# traceroute 8.8.8.8
   > traceroute to 8.8.8.8 (8.8.8.8), 30 hops max, 60 byte packets
   >  1  gateway (192.168.2.1)  0.215 ms  0.094 ms  0.068 ms
   >  2  * * *
   >  3  * * *
   >  4  * * *
   > ```
   > 上記の例では、8.8.8.8のアドレスに通信に行くためにまずgatewayの192.168.2.1を通過していることがわかる。
- nmapコマンド
   > pingコマンドでの疎通後もしくは疎通できない場合に併用して、nmapコマンドなどでポートが開いているかどうかを確認する。
   > ```
   > [root@localhost ~]# nmap 192.168.2.1 -p22
   >
   > Starting Nmap 6.40 ( http://nmap.org ) at 2024-12-03 10:35 JST
   > Nmap scan report for 192.168.2.1
   > Host is up (0.00045s latency).
   > POST     STATE    SERVICE
   > 22/tcp XXXX  XXXX
   >
   > Nmap done: 1 IP address (1 host up) scanned in 0.52 seconds
   > ```
   > 上記例では192.168.2.1のサーバのTCPポート22と疎通できるかどうかを確認している。
   > 結果のSTATEがopenとなっていればサーバのポートまで疎通できていることが確認できる。  
   > filterdとなっていれば、NWの経路上に問題があり、closedとなっていれば、相手のサーバのそのポートが待ち状態になっていないということである。
- nmcliコマンド
   > pingも通らない、arpも何も見えないような場合は、こちら側の設定が正しいかを確認する必要がある。
   > ifconfigやip addrコマンドを使って、IPが設定されていることを確認したのに、NW疎通ができない原因として、「デバイス名とコネクションの設定が間違っている」ということがある。
   > ```
   > [root@localhost ~]# nmcli d
   > デバイス　タイプ　　状態  　　接続
   > ens33      ethernet  接続済み  ens33
   > lo         loopback  管理無し  --
   > [root@localhost ~]# nmcli c
   > 名前　　UUID                               タイプ　　　　　デバイス
   > ens33    XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXX 802-3-ethernet  ens33
   > ```
   > nmcli d で表示されたデバイスとnmcli c　で表示されたデバイス
   > nmcli dっで表示された接続と、nmcli cで表示された名前が一致することを確認
   > さらに、その名前が、/etc/sysconfig/networkscripts/ifcfg-ens33　のようにifcfg-<デバイス名>となっていて、中身のNAMEとDEVICEが同じ名前になっていることを確認
# 12/4(Wed)
バイナリコードからアセンブリコードを出力するLLMにpolybenchデータセットをファインチューニングした。  
なんのコードで出力確認する？

バイナリからアセンブリコード 2mmを使用  
<details><summary>2mm</summary>

```
endbr64
push   %rbp
mov    %rsp,%rbp
mov    %edi,-0x14(%rbp)
mov    %esi,-0x18(%rbp)
mov    %edx,-0x1c(%rbp)
mov    %ecx,-0x20(%rbp)
mov    %r8,-0x28(%rbp)
mov    %r9,-0x30(%rbp)
mov    -0x28(%rbp),%rax
movsd  0xc12(%rip),%xmm0        # 0x2020
movsd  %xmm0,(%rax)
mov    -0x30(%rbp),%rax
movsd  0xc0a(%rip),%xmm0        # 0x2030
movsd  %xmm0,(%rax)
movl   $0x0,-0x8(%rbp)
jmp    12fe <polybench_flush_cache+0xa6>
movl   $0x0,-0x4(%rbp)
jmp    12ec <polybench_flush_cache+0x94>
mov    -0x8(%rbp),%eax
imul   -0x4(%rbp),%eax
add    $0x1,%eax
cltd
idivl  -0x14(%rbp)
mov    %edx,%eax
pxor   %xmm0,%xmm0
cvtsi2sd %eax,%xmm0
pxor   %xmm1,%xmm1
cvtsi2sdl -0x14(%rbp),%xmm1
mov    -0x8(%rbp),%eax
cltq
imul   $0x2260,%rax,%rdx
mov    0x10(%rbp),%rax
add    %rax,%rdx
divsd  %xmm1,%xmm0
mov    -0x4(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x1c(%rbp),%eax
jl     12a6 <polybench_flush_cache+0x4e>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x14(%rbp),%eax
jl     129d <polybench_flush_cache+0x45>
movl   $0x0,-0x8(%rbp)
jmp    135e <polybench_flush_cache+0x106>
movl   $0x0,-0x4(%rbp)
jmp    134e <polybench_flush_cache+0xf6>
mov    -0x4(%rbp),%eax
add    $0x1,%eax
imul   -0x8(%rbp),%eax
cltd
idivl  -0x18(%rbp)
mov    %edx,%eax
pxor   %xmm0,%xmm0
cvtsi2sd %eax,%xmm0
pxor   %xmm1,%xmm1
cvtsi2sdl -0x18(%rbp),%xmm1
mov    -0x8(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    0x18(%rbp),%rax
add    %rax,%rdx
divsd  %xmm1,%xmm0
mov    -0x4(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x18(%rbp),%eax
jl     1308 <polybench_flush_cache+0xb0>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x1c(%rbp),%eax
jl     12ff <polybench_flush_cache+0xa7>
movl   $0x0,-0x8(%rbp)
jmp    13c6 <polybench_flush_cache+0x16e>
movl   $0x0,-0x4(%rbp)
jmp    13b6 <polybench_flush_cache+0x15e>
mov    -0x4(%rbp),%eax
add    $0x3,%eax
imul   -0x8(%rbp),%eax
add    $0x1,%eax
cltd
idivl  -0x20(%rbp)
mov    %edx,%eax
pxor   %xmm0,%xmm0
cvtsi2sd %eax,%xmm0
pxor   %xmm1,%xmm1
cvtsi2sdl -0x20(%rbp),%xmm1
mov    -0x8(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x20(%rbp),%rax
add    %rax,%rdx
divsd  %xmm1,%xmm0
mov    -0x4(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x20(%rbp),%eax
jl     136d <polybench_flush_cache+0x115>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x18(%rbp),%eax
jl     1364 <polybench_flush_cache+0x10c>
movl   $0x0,-0x8(%rbp)
jmp    1438 <polybench_flush_cache+0x1e0>
movl   $0x0,-0x4(%rbp)
jmp    1428 <polybench_flush_cache+0x1d0>
mov    -0x4(%rbp),%eax
add    $0x2,%eax
imul   -0x8(%rbp),%eax
cltd
idivl  -0x1c(%rbp)
mov    %edx,%eax
pxor   %xmm0,%xmm0
cvtsi2sd %eax,%xmm0
pxor   %xmm1,%xmm1
cvtsi2sdl -0x1c(%rbp),%xmm1
mov    -0x8(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x28(%rbp),%rax
add    %rax,%rdx
divsd  %xmm1,%xmm0
mov    -0x4(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x20(%rbp),%eax
jl     13e2 <polybench_flush_cache+0x18a>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x14(%rbp),%eax
jl     13d9 <polybench_flush_cache+0x181>
nop
nop
pop    %rbp
ret

endbr64
push   %rbp
mov    %rsp,%rbp
sub    $0x20,%rsp
mov    %edi,-0x14(%rbp)
mov    %esi,-0x18(%rbp)
mov    %edx,-0x20(%rbp)
mov    0x2932(%rip),%rax        # 4020 <polybench_inter_array_padding_sz>
mov    %rax,%rcx
mov    $0x16,%edx
mov    $0x1,%esi
lea    0x9be(%rip),%rax        # 2040 <__PRETTY_FUNCTION__.0+0x20>
mov    %rax,%rdi
call   1140 <polybench_flush_cache>
mov    0x290f(%rip),%rax        # 4030 <polybench_inter_array_padding_sz+0x10>
lea    0x9bf(%rip),%rdx        # 2057 <__PRETTY_FUNCTION__.0+0x37>
lea    0x9ba(%rip),%rcx        # 205b <__PRETTY_FUNCTION__.0+0x3b>
mov    %rcx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
call   1120 <polybench_prepare_instruments>
movl   $0x0,-0x8(%rbp)
jmp    1589 <init_array+0x116>
movl   $0x0,-0x4(%rbp)
jmp    1579 <init_array+0x106>
mov    -0x8(%rbp),%eax
imul   -0x14(%rbp),%eax
mov    %eax,%edx
mov    -0x4(%rbp),%eax
lea    (%rdx,%rax,1),%ecx
movslq %ecx,%rax
imul   $0x66666667,%rax,%rax
shr    $0x20,%rax
mov    %eax,%edx
sar    $0x3,%edx
mov    %ecx,%eax
sar    $0x1f,%eax
sub    %eax,%edx
mov    %edx,%eax
shl    $0x2,%eax
add    %edx,%eax
shl    $0x2,%eax
sub    %eax,%ecx
mov    %ecx,%edx
test   %edx,%edx
jne    1528 <init_array+0xb5>
mov    0x2897(%rip),%rax        # 4040 <polybench_inter_array_padding_sz+0x20>
mov    %rax,%rsi
mov    $0xa,%edi
call   1180 <rand>
mov    -0x8(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    -0x20(%rbp),%rax
add    %rax,%rdx
mov    -0x4(%rbp),%eax
cltq
mov    (%rdx,%rax,8),%rdx
mov    0x2867(%rip),%rax        # 4048 <polybench_inter_array_padding_sz+0x28>
movq   %rdx,%xmm0
lea    0x923(%rip),%rdx        # 2068 <__PRETTY_FUNCTION__.0+0x48>
mov    %rdx,%rsi
mov    %rax,%rdi
mov    $0x1,%eax
call   1160 <polybench_warning>
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x18(%rbp),%eax
jl     14e7 <init_array+0x74>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x14(%rbp),%eax
jl     14db <init_array+0x68>
mov    0x2824(%rip),%rax        # 4020 <polybench_inter_array_padding_sz>
lea    0x8d4(%rip),%rdx        # 2077 <__PRETTY_FUNCTION__.0+0x57>
lea    0x8e6(%rip),%rcx        # 2081 <__PRETTY_FUNCTION__.0+0x61>
mov    %rcx,%rsi
mov    %rax,%rdi
mov    $0x0,%eax
call   1120 <polybench_prepare_instruments>
mov    0x27ff(%rip),%rax        # 4030 <polybench_inter_array_padding_sz+0x10>
mov    %rax,%rcx
mov    $0x16,%edx
mov    $0x1,%esi
lea    0x8cc(%rip),%rax        # 2087 <__PRETTY_FUNCTION__.0+0x67>
mov    %rax,%rdi
call   1140 <polybench_flush_cache>
nop
leave
ret

endbr64
push   %rbp
mov    %rsp,%rbp
mov    %edi,-0x14(%rbp)
mov    %esi,-0x18(%rbp)
mov    %edx,-0x1c(%rbp)
mov    %ecx,-0x20(%rbp)
movsd  %xmm0,-0x28(%rbp)
movsd  %xmm1,-0x30(%rbp)
mov    %r8,-0x38(%rbp)
mov    %r9,-0x40(%rbp)
movl   $0x0,-0xc(%rbp)
jmp    1746 <kernel_gemm+0x11d>
movl   $0x0,-0x8(%rbp)
jmp    1736 <kernel_gemm+0x10d>
mov    -0xc(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    -0x38(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
pxor   %xmm0,%xmm0
movsd  %xmm0,(%rdx,%rax,8)
movl   $0x0,-0x4(%rbp)
jmp    1726 <kernel_gemm+0xfd>
mov    -0xc(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    -0x38(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm1
mov    -0xc(%rbp),%eax
cltq
imul   $0x2260,%rax,%rdx
mov    -0x40(%rbp),%rax
add    %rax,%rdx
mov    -0x4(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm0
movapd %xmm0,%xmm2
mulsd  -0x28(%rbp),%xmm2
mov    -0x4(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    0x10(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm0
mulsd  %xmm2,%xmm0
mov    -0xc(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    -0x38(%rbp),%rax
add    %rax,%rdx
addsd  %xmm1,%xmm0
mov    -0x8(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x1c(%rbp),%eax
jl     169d <kernel_gemm+0x74>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x18(%rbp),%eax
jl     165f <kernel_gemm+0x36>
addl   $0x1,-0xc(%rbp)
mov    -0xc(%rbp),%eax
cmp    -0x14(%rbp),%eax
jl     1653 <kernel_gemm+0x2a>
movl   $0x0,-0xc(%rbp)
jmp    1855 <kernel_gemm+0x22c>
movl   $0x0,-0x8(%rbp)
jmp    1845 <kernel_gemm+0x21c>
mov    -0xc(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x20(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm0
mov    -0xc(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x20(%rbp),%rax
add    %rax,%rdx
mulsd  -0x30(%rbp),%xmm0
mov    -0x8(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
movl   $0x0,-0x4(%rbp)
jmp    17eb <kernel_gemm+0x1c2>
mov    -0xc(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x20(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm1
mov    -0xc(%rbp),%eax
cltq
imul   $0x1c20,%rax,%rdx
mov    -0x38(%rbp),%rax
add    %rax,%rdx
mov    -0x4(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm2
mov    -0x4(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x18(%rbp),%rax
add    %rax,%rdx
mov    -0x8(%rbp),%eax
cltq
movsd  (%rdx,%rax,8),%xmm0
mulsd  %xmm2,%xmm0
mov    -0xc(%rbp),%eax
cltq
imul   $0x2580,%rax,%rdx
mov    0x20(%rbp),%rax
add    %rax,%rdx
addsd  %xmm1,%xmm0
mov    -0x8(%rbp),%eax
cltq
movsd  %xmm0,(%rdx,%rax,8)
addl   $0x1,-0x4(%rbp)
mov    -0x4(%rbp),%eax
cmp    -0x18(%rbp),%eax
jl     176b <kernel_gemm+0x142>
addl   $0x1,-0x8(%rbp)
mov    -0x8(%rbp),%eax
cmp    -0x20(%rbp),%eax
jl     171c <kernel_gemm+0xf3>
addl   $0x1,-0xc(%rbp)
mov    -0xc(%rbp),%eax
cmp    -0x14(%rbp),%eax
jl     1700 <kernel_gemm+0xd7>
nop
nop
pop    %rbp
ret

endbr64
push   %rbp
mov    %rsp,%rbp
sub    $0x60,%rsp
mov    %edi,-0x54(%rbp)
mov    %rsi,-0x60(%rbp)
mov    %fs:0x28,%rax
mov    %rax,-0x8(%rbp)
xor    %eax,%eax
movl   $0x320,-0x50(%rbp)
movl   $0x384,-0x4c(%rbp)
movl   $0x44c,-0x48(%rbp)
movl   $0x4b0,-0x44(%rbp)
mov    $0x8,%esi
mov    $0xafc80,%edi
call   12b0 <polybench_alloc_data>
mov    %rax,-0x30(%rbp)
mov    $0x8,%esi
mov    $0xd6d80,%edi
call   12b0 <polybench_alloc_data>
mov    %rax,-0x28(%rbp)
mov    $0x8,%esi
mov    $0xf1b30,%edi
call   12b0 <polybench_alloc_data>
mov    %rax,-0x20(%rbp)
mov    $0x8,%esi
mov    $0x107ac0,%edi
call   12b0 <polybench_alloc_data>
mov    %rax,-0x18(%rbp)
mov    $0x8,%esi
mov    $0xea600,%edi
call   12b0 <polybench_alloc_data>
mov    %rax,-0x10(%rbp)
lea    -0x38(%rbp),%r8
lea    -0x40(%rbp),%rdi
mov    -0x44(%rbp),%ecx
mov    -0x48(%rbp),%edx
mov    -0x4c(%rbp),%esi
mov    -0x50(%rbp),%eax
push   -0x10(%rbp)
push   -0x18(%rbp)
push   -0x20(%rbp)
push   -0x28(%rbp)
mov    %r8,%r9
mov    %rdi,%r8
mov    %eax,%edi
call   1490 <init_array>
add    $0x20,%rsp
movsd  -0x38(%rbp),%xmm0
mov    -0x40(%rbp),%rdi
mov    -0x28(%rbp),%r9
mov    -0x30(%rbp),%r8
mov    -0x44(%rbp),%ecx
mov    -0x48(%rbp),%edx
mov    -0x4c(%rbp),%esi
mov    -0x50(%rbp),%eax
sub    $0x8,%rsp
push   -0x10(%rbp)
push   -0x18(%rbp)
push   -0x20(%rbp)
movapd %xmm0,%xmm1
movq   %rdi,%xmm0
mov    %eax,%edi
call   161d <kernel_gemm>
add    $0x20,%rsp
cmpl   $0x2a,-0x54(%rbp)
jle    1a1b <main+0x10f>
mov    -0x60(%rbp),%rax
mov    (%rax),%rax
movzbl (%rax),%eax
movzbl %al,%eax
test   %eax,%eax
jne    1a1b <main+0x10f>
mov    -0x10(%rbp),%rdx
mov    -0x44(%rbp),%ecx
mov    -0x50(%rbp),%eax
mov    %ecx,%esi
mov    %eax,%edi
call   13b0 <print_array>
mov    -0x30(%rbp),%rax
mov    %rax,%rdi
call   12e0 <free@plt>
mov    -0x28(%rbp),%rax
mov    %rax,%rdi
call   12e0 <free@plt>
mov    -0x20(%rbp),%rax
mov    %rax,%rdi
call   12e0 <free@plt>
mov    -0x18(%rbp),%rax
mov    %rax,%rdi
call   12e0 <free@plt>
mov    -0x10(%rbp),%rax
mov    %rax,%rdi
call   12e0 <free@plt>
mov    $0x0,%eax
mov    -0x8(%rbp),%rdx
sub    %fs:0x28,%rdx
je     1a82 <main+0x176>
call   12f0 <__stack_chk_fail@plt>
leave
ret
```

</details>

# 12/9(Mon)
アセンブリコードをCコードに

<details><summary>2mm</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* trisolv.c: this file is part of PolyBench/C */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>
/* Include benchmark-specific header. */
#include "trisolv.h"

/* Array initialization. */
static void init_array(int n,
    DATA_TYPE POLYBENCH_2D(L, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(b, N, n)) {
  int i, j;
  for (i = 0; i < n; i++) {
    x[i] = -999;
    b[i] = i;
    for (j = 0; j <= i; j++)
      L[i][j] = (DATA_TYPE)(i + n - j + 1) * 2 / n;
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n,
    DATA_TYPE POLYBENCH_1D(x, N, n)) {
  int i;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("x");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, x[i]);
  }
  POLYBENCH_DUMP_END("x");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_trisolv(int n,
    DATA_TYPE POLYBENCH_2D(L, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(b, N, n)) {
  int i, j;
  DATA_TYPE xi;
#pragma scop
  for (i = 0; i < _PB_N; i++) {
    xi = b[i];
    for (j = 0; j < i; j++)
      xi -= L[i][j] * x[j];
    x[i] = xi / L[i][i];
  }
#pragma endscop
}

int main(int argc, char** argv) {
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(L, DATA_TYPE, N, N, n, n);
  POLYBENCH_1D_ARRAY_DECL(x, DATA_TYPE, N, n);
  POLYBENCH_1D_ARRAY_DECL(b, DATA_TYPE, N, n);

  /* Initialize array(s). */
  init_array(n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_trisolv(n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(x)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(L);
  POLYBENCH_FREE_ARRAY(x);
  POLYBENCH_FREE_ARRAY(b);

  return 0;
}
```

</details>

trisolvのCコードに変換されてしまった。下三角行列に対する前進代入法

<details><summary>lu</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* trisolv.c: this file is part of PolyBench/C */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>
/* Include benchmark-specific header. */
#include "trisolv.h"

/* Array initialization. */
static void init_array(int n,
    DATA_TYPE POLYBENCH_2D(L, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(b, N, n)) {
  int i, j;
  for (i = 0; i < n; i++) {
    x[i] = -999;
    b[i] = i;
    for (j = 0; j <= i; j++)
      L[i][j] = (DATA_TYPE)(i + n - j + 1) * 2 / n;
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n,
    DATA_TYPE POLYBENCH_1D(x, N, n)) {
  int i;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("x");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, x[i]);
  }
  POLYBENCH_DUMP_END("x");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_trisolv(int n,
    DATA_TYPE POLYBENCH_2D(L, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(b, N, n)) {
  int i, j;
  DATA_TYPE xi;
#pragma scop
  for (i = 0; i < _PB_N; i++) {
    xi = b[i];
    for (j = 0; j < i; j++)
      xi -= L[i][j] * x[j];
    x[i] = xi / L[i][i];
  }
#pragma endscop
}

int main(int argc, char** argv) {
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(L, DATA_TYPE, N, N, n, n);
  POLYBENCH_1D_ARRAY_DECL(x, DATA_TYPE, N, n);
  POLYBENCH_1D_ARRAY_DECL(b, DATA_TYPE, N, n);

  /* Initialize array(s). */
  init_array(n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_trisolv(n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(x)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(L);
  POLYBENCH_FREE_ARRAY(x);
  POLYBENCH_FREE_ARRAY(b);

  return 0;
}
```

</details>

これも同様にtrisolvと認識された。下三角行列に対する前進代入法  

polybenchではない、LU分解のCコードを試行

<details><summary>元のコード</summary>

```c
#include <stdio.h>
#include <math.h>
#define DIM 3

int main()
{
    int i, j, k, m, n, dim, maxline;
    float temp, alpha, reserve, sum1, sum2;
    float A[DIM][DIM],L[DIM][DIM],U[DIM][DIM];
    float b[DIM],x[DIM],y[DIM];

//  input matrix-------------------------------------------
//  A
    printf("input Matrix\n");
    for(i = 0; i < DIM; i++){
        for(j = 0; j < DIM; j++){
            printf("A[%d][%d]:", i+1, j+1);
            scanf("%f", &A[i][j]);
            L[i][j] = 0.0;
            U[i][j] = 0.0;
        }
    }

//  B
    for(i = 0; i < DIM; i++){
        printf("B[%d]:", i+1);
        scanf("%f", &b[i]);
    }
//  -------------------------------------------------------
//  output to input----------------------------------------
    printf("A\n");
    for(i = 0; i < DIM; i++){
        for(j = 0; j < DIM; j++){
            printf(" %f ",A[i][j]);
        }
        printf("\n");
    }

    printf("B\n");
    for(i = 0; i < DIM; i++){
        printf(" %f \n",b[i]);
    }
//  -------------------------------------------------------
//  LU ----------------------------------------------------
    for(i = 0; i < DIM; i++){
        L[i][i] = 1.0;
    }
    for(i = 0; i < DIM; i++){
        for(j = 0; j < DIM; j++){
            if( i <= j){
                sum1 = 0.0;
                for(m = 0; m <= i-1; m++){
                    sum1 += L[i][m] * U[m][j];
                }
                U[i][j] = A[i][j] - sum1;
            }
            else if(i > j){
                sum2 = 0.0;
                for(n = 0; n <= j-1; n++){
                    sum2 += L[i][n] * U[n][j];
                }
                L[i][j] = (A[i][j] - sum2) / U[j][j];
            }
        }
    }
//  -------------------------------------------------------
//  output for LU------------------------------------------
//  L------------------------------------------------------
    printf("L\n");
    for(i = 0; i < DIM; i++){
        for(j = 0; j < DIM; j++){
            printf(" %f ",L[i][j]);
        }
        printf("\n");
    }
//  U------------------------------------------------------
    printf("U\n");
    for(i = 0; i < DIM; i++){
        for(j = 0; j < DIM; j++){
            printf(" %f ",U[i][j]);
        }
        printf("\n");
    }
//  -------------------------------------------------------
//  solve the problem--------------------------------------
//  Ly = b-------------------------------------------------
    for(i = 0; i < DIM; i++){
        y[i] = b[i];
    }

    for(j = 0; j < DIM-1; j++){
        for(i = j+1; i < DIM; i++){
            y[i] -= y[j] * L[i][j];
        }
    }

//  Ux = y
    for(i = 0; i < DIM; i++){
        x[i] = y[i];
    }

    for(j = DIM-1; j >= 0; j--){
        x[j] /= U[j][j];
        for (i = 0; i <= j-1; i++){
            x[i] -= U[i][j] * x[j];
        }
    }
//  -------------------------------------------------------
//  output x-----------------------------------------------
    printf("x\n");
    for(i = 0; i < DIM; i++){
        printf("x[%d] = %f\n",i+1,x[i]);
    }
}

```

</details>

<details><summary>LLM</summary>

```c
/**
 * Contributors : GeeksforGeeks (Mr. Pranjal Awasthi)
 * Compilation : GCC (Linux) 4.8.4
 *
 * Note:
 * This code is made to work as a stand-alone program.
 *
 * Compilation command: gcc standalone_prgm.c
 * Execution command: ./a.out
 *
 * WARNING: Please don't change anything above this line.
 */

/* Program to find the inverse of a matrix */

/* Importing required libraries */
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

/* Defining standard constants */
#define N 3
#define inv(x) power(x, MOD - 2, MOD)
#define INT_MAX 1e9
#define uround(a) ((N * a) + 0.5) / N
#define EPSILON ((float)0.001)

/* Functions to read a matrix (row-major initialized), display
 * a matrix, and to get cofactor of a matrix */
void display(float mat[N][N]) {
    int i, j;
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            printf("%f ", mat[i][j]);
        }
        printf("\n");
    }
}

void getCofactor(float mat[N][N], float temp[N][N], int p, int q, int n) {
    int i = 0, j = 0;
    int row, col;

    for (row = 0; row < n; row++)
        for (col = 0; col < n; col++)
            if (row != p && col != q) {
                temp[i][j++] = mat[row][col];
                if (j == n - 1) {
                    j = 0;
                    i++;
                }
            }
}

/* Recursive function for finding determinant of matrix.
 * n is current dimension of mat[][].
 *
 * det(mat) = sum of mat[0][f] * cofactor(mat[0][f])
 * where f = 0, 1, 2, ...
 * det(mat) = mat[0][0]*(mat[1][1]* mat[2][2] - mat[2][1]* mat[1][2])
 * mat[0][1]*(mat[1][0]* mat[2][2] - mat[2][0]* mat[1][2])
 * mat[0][2]*(mat[1][0]* mat[2][1] - mat[2][0]* mat[1][1])
 */
float determinant(float matrix[N][N], int size) {
    int i, j;
    float det = 0;

    if (size == 1)
        return matrix[0][0];

    if (size == 2)
        return (matrix[0][0] * matrix[1][1] - matrix[1][0] * matrix[0][1]);

    float submatrix[N][N];
    for (i = 0; i < size; i++) {
        getCofactor(matrix, submatrix, 0, i, size);
        det = det + (float)(matrix[0][i] * determinant(submatrix, size - 1) * (i % 2 == 0 ? 1 : -1));
    }
    return det;
}

/* Function to get adjoint of matrix */
void adjoint(float mat[N][N], float adj[N][N]) {
    int i, j;
    if (N == 1) {
        adj[0][0] = 1;
        return;
    }

    int sign = 1;
    float temp[N][N];

    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            getCofactor(mat, temp, i, j, N);
            sign = ((i + j) % 2 == 0) ? 1 : -1;
            adj[j][i] = (sign) * (determinant(temp, N - 1));
        }
    }
}

/* Function to calculate and store inverse, returns 1 if matrix is invertible */
int inverse(float mat[N][N], float inverse[N][N]) {
    int i, j;
    // Find determinant of A
    float det = determinant(mat, N);
    if (det == 0) {
        printf("Singular matrix, can't find its inverse");
        return 0;
    }

    // Find adjoint
    float adj[N][N];
    adjoint(mat, adj);

    // Find Inverse using formula "inverse(A) = adj(A)/det(A)"
    for (i = 0; i < N; i++)
        for (j = 0; j < N; j++)
            inverse[i][j] = adj[i][j] / det;

    return 1;
}

/* QA MODULE ❤️
 * TEST CASE 1:
 *  float A[N][N] = { { 2, -1, 0 }, { -1, 2, -1 }, { 0, -1, 2 } };
 *  Expected Output:
 *  0.75, 0.5, 0.25
 *  0.5, 1, 0.5
 *  0.25, 0.5, 0.75
 * TEST CASE 2:
 *  float A[N][N] = { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } };
 *  Expected Output:
 *  Singular matrix, can't find its inverse
 * TEST CASE 3:
 *  float A[N][N] = { { 3, -2, 5 }, { -10, 4, 5 }, { 1, 6, -2 } };
 *  Expected Output:
 *  -0.1102, -0.1771, 0.3710
 *  0.0720, 0.2703, -0.1261
 *  0.0495, 0.2846, -0.0963
 * TEST CASE 4:
 *  float A[N][N] = { { 5, -2, 2 }, { 3, 1, 7 }, { 5, 0, 8 } };
 *  Expected Output:
 *  0.1368, -0.2105, 0.0526
 *  0.6842, 0.2632, -0.5263
 *  -0.4211, 0.1053, 0.1053
 * TEST CASE 5:
 *  float A[N][N] = { { 3, 5, 8}, { 6, 8, 9 }, { 4, 5, 6 } };
 *  Expected Output:
 *  -0.8333, 0.8333, -0.3333
 *  -1.0000, 2.0000, -1.0000
 *  1.3333, -2.3333, 1.3333
 * TEST CASE 6:
 * 
 * MULTIPLE TEST CASES CAN BE ADDED BELOW
 * 
 * IMPORTANT: Please use assert statement to validate your testcases
 * Assert(int boolean_expression) statement can be used to test
 * your test cases.. Assert statements exit with an error if the provided
 * boolean expression is false, can be used in the following way
 * int main() { int a = 2; assert(a == 0); }
 */

void test();

/* MAIN DRIVER */
float A[N][N] = {
    { 3, 2, 6 },
    { 0, 5, 0 },
    { 8, 0, 9 },
};

int main() {
    int i, j;
    float adj[N][N];       // To store adjoint of A
    float inv[N][N] = { 0 }; // To store inverse of A

    printf("Input matrix is :\n");
    display(A);

    printf("\nThe Inverse is: \n");
    if (inverse(A, inv))
        display(inv);

    return 0;
}
```

</details>

コードは、3x3の行列を対象に、行列の逆行列を計算している。プログラムは、行列の表示、余因子の取得、行列式の計算、補行列（adjoint）の計算、逆行列の計算を行う関数群がある。また、テストケースはコメントで示され、コメント数が多く出力されるようになった。LU分解は行っていない。

<details><summary>trisolv</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* nussinov.c: this file is part of PolyBench/C */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "nussinov.h"

/* RNA bases represented as chars, range is [0,3]. */
#define BASE_A 0
#define BASE_C 1
#define BASE_G 2
#define BASE_U 3

/* RNA sequence as a string of bases; N is the length of the string. */
static int seq[N];
static int match[4][4] = {
  { 0, 0, 0, 1 },
  { 0, 0, 1, 0 },
  { 0, 1, 0, 0 },
  { 1, 0, 0, 0 }
};

/* Array initialization. */
static void init_array(int n, int seq[n], DATA_TYPE POLYBENCH_2D(table, N, N, n, n)) {
  int i, j;
  const unsigned int seed = 42;
  srand(seed);
  for (i = 0; i < n; i++) {
    seq[i] = rand() % 4;
  }
}

/* Print benchmark results. */
static void print_array(int n, DATA_TYPE POLYBENCH_2D(table, N, N, n, n)) {
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("table");
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      if (table[i][j] != 0) {
        if ((i + j) % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
        fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, table[i][j]);
      }
    }
  POLYBENCH_DUMP_END("table");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_nussinov(int n, int seq[n], DATA_TYPE POLYBENCH_2D(table, N, N, n, n)) {
  int i, j, k;
#pragma scop
  for (i = n - 1; i >= 0; i--) {
    for (j = i + 1; j < n; j++) {
      if (j - 1 >= 0)
        table[i][j] = MAX(table[i][j], table[i][j - 1]);
      if (i + 1 < n)
        table[i][j] = MAX(table[i][j], table[i + 1][j]);
      if (j - 1 >= 0 && i + 1 < n) {
        if (i < j - 1)
          table[i][j] = MAX(table[i][j], table[i + 1][j - 1] + match[seq[i]][seq[j]]);
        else
          table[i][j] = MAX(table[i][j], table[i + 1][j - 1]);
      }
      for (k = i + 1; k < j; k++) {
        table[i][j] = MAX(table[i][j], table[i][k] + table[k + 1][j]);
      }
    }
  }
#pragma endscop
}

int main(int argc, char** argv) {
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(table, DATA_TYPE, N, N, n, n);

  /* Initialize array(s). */
  init_array(n, seq, POLYBENCH_ARRAY(table));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_nussinov(n, seq, POLYBENCH_ARRAY(table));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(table)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(table);
  return 0;
}
```

</details>

これまた異なるプログラムを出力した。  
nussinov	Dynamic programming algorithm for sequence alignment

# 12/10(Tu)
コードが長くて誤認してしまうのだろうか、、、  
データセットの問題  

# 12/17(Tu)
**機械学習における「validation」と「test」の違い**  
1. なぜtrainデータ以外のデータが必要なのか？
> **trainデータを使って学習したモデルがtarinデータ以外のデータに対してどれぐらいの予測精度があるか確認する必要があるから。**  
> データを使った学習では、原則として学習に使ってデータ(trainデータ)に対する予測精度しか考慮していない。  
> なので「tarinデータに対しては良い精度で予測できるがそれ以外のデータでは予測が全く当てにならない」という学習結果も起こりうる(→過学習)  
> 過学習がどの程度起こっているかは実際にtarinデータ以外のデータで予測をしてみないとわからないので、そのためのtrainデータと別のデータが必要になる。  
> ここで過学習の確認のため使うデータをvalidationデータと呼ぶ。
2. なぜteatデータが必要なのか？
> **trainデータとvalidationデータに過学習していないか確認する必要があるから。**  
> trainデータで学習してvalidationデータで評価して学習時のハイパーパラメータをチューニングすることを繰り返すと、「train/validationデータに対して良い精度で予測できるがそれ以外のデータでは予測が全く当てにならない」という結果も起こりうる(trainデータとvalidationデータに対する過学習)  
> なので、validationデータが必要なのと同様に「trainデータとvalidationデータに対する過学習」がどの程度起こっているか確認するための**testデータ**が必要になる。  
> また、validationデータによる評価はしばしば学習の終了判定に用いられる。  
> この場合もvalidationデータの内容に依存したモデルを選ぶことになるため、testデータによる確認が必要である。  
>
> validationデータでの評価を受けて再学習するという反復を行わない場合(モデルや学習方法を事前に決めている場合、単にアルゴリズムの性能を調べたい場合等)はvalidationデータに対する過学習は起きにくいと考えられる。  
> その場合はtestデータが必要にならない。  
>
> 実務上はtrain/validationデータにモデル作成のための作為性が含まれている可能性を考えて、本番環境で取得したデータをtestデータとして使う意味合いを持たせることもある。  
>
> testデータに対する評価がモデルの最終評価となるため、このデータには本番環境に対しての差異や偏りが存在しないよう注意する必要がある。  
3. testデータに対する過学習は考えなくて良いのか？
> **考える必要がある。そのため「testデータで評価した後はモデルを更新してはいけない」と言われる。**  
> testデータに対する予測結果を受けて学習時のハイパーパラメータのチューニングやモデルの再学習をするとtrainデータとvalidationデータとtestデータに対する過学習が起こっていく。  
> しかしtestデータでの評価が満足でない場合にモデルの更新ができないと困るので、以下の対応が取られる。  
>
> **対策1. あらかじめ複数のモデルを作成しておく**  
> 候補となるモデルを複数作っていき、testデータでの評価によって最終的にモデルを選択する。  
> PoC等でモデルの候補が限定されている場合には有効だが、一般には作成した全てのモデルで十分な精度を得られないリスクがある。  
> 他にtestデータを用意し直すコストが高い場合にもこの施策が必要になる。  
>
> **対策2. 評価の度に新たなtestデータを使う**  
> 本番環境等でデータを取得する環境が整っていれば一度評価に使ったtestデータは破棄するかtrain/validationデータと合併するかして、新たに収集したデータをtestデータとして評価に使うことができる。  
> 異なるデータでの評価結果は単純比較できない場合も多いので、以前のモデルも新たなtestデータで評価して新たなモデルと比較するとよい。  
>
> また、一組のデータセットをtrain/validation/testに分割してモデルを作成する場合は、分割方法を変えることで擬似的に新たなtestデータを得ることができる。
> ただし実際にはtrain/validationに使ったデータをtestデータとして評価することになるので、評価と再分割を繰り返すことで過学習が進んでいくことに注意する。  
>
> さらに、更新したtestデータに偏りがあるなど品質面で問題があった場合、過去のtestデータに対しての精度が悪化していることに気づけなくなってしまう懸念も存在する。  
> 過去のtestデータやそれに対応したモデルも保持しておき、新しいtestデータのものと比較することでこの問題を緩和することはできる。  
> **対策3. testデータへの過学習に目を瞑る**  
> validationの時点で十分な精度が見込まれる等、testデータによる評価の回数が少なそうな場合は多少の過学習を無視してtestデータを使い回してもよい。    
> 発展して、validationデータへの過学習を許容してtestデータによる評価を行わない場合もある。  
4. クロスバリデーション(公差検証)ってなにゆえやるのか？  
> **「たまたま精度が良くなるtrain/validationの組合わせだった」という偏りを避けるため**  
> **testデータは学習に使われることを避けるためクロスバリデーションは適用しない。**  
> モデル作成には学習/評価に使ったデータが持つ偏りが大きく影響し、「tarinデータで学習したモデルをvalidationデータで評価するとたまたま良い精度が出た」という結果が起こりうる。  
> そのためできるだけ様々な組合わせのtrain/validationデータでモデルを学習/評価することが望ましい。  
> その効率的な組合わせ方を与える方法が、一組のデータセットをいくつかに分割してtrain/validationデータに振り分けるクロスバリデーションである。  
>
> testデータは学習やモデルチューニングに使わなかったデータでモデルを評価するという目的があるため、クロスバリデーションの枠組みで扱う(分割したデータのいずれかをtestデータに割り振る)ことはしない方がよい。

# 12/18(Wed)
訓練データ、テストデータ共にpolybenchを用いた。アセンブリコードをCコードにするモデルを使用した。  
<img width="364" alt="image" src="https://github.com/user-attachments/assets/387cc650-6681-46f1-b015-bce8a43c0fc3" />  

training loss:訓練データにおける損失  
validation loss:テストデータにおける損失  
full validation loss:バリデーションデータセット全体の損失の平均を意味  

### **考察**
1. **トレーニング損失 (Training loss)**  
   - トレーニング損失が**0.0204**と非常に低い値。  
   - モデルはトレーニングデータに対して適切にフィットしている。

2. **検証損失 (Validation loss)**  
   - 検証損失が**0.0301**であり、トレーニング損失よりも高い値。  
   - この差はモデルが**訓練データに若干適合しすぎている**（過学習の兆候）ことを示しているが、大きな差ではない。

3. **完全な検証損失 (Full validation loss)**  
   - 完全な検証損失（0.0277）は検証損失（0.0301）よりわずかに低い。  
   - **完全な検証損失**はデータ全体または別の手法で算出された値と考えられ、これは通常の検証損失よりもモデルの性能を安定して示すことが多い。  
   - **0.0277**はトレーニング損失とのギャップが小さく、モデルが過学習している可能性は少ないと考えられる。

---

### **グラフの分析**
1. **Training Lossの推移**（緑の線）  
   - 学習初期（エポック1付近）で大きな値を示し、徐々に減少していることから学習が順調に進んでいると考えられる。
   - 途中にいくつかのスパイク（急上昇）が見られるが、最終的には収束している。

2. **Validation Lossの推移**（紫の線）  
   - **Validation loss**が安定して減少しており、大きな上昇傾向は見られない。  
   - トレーニング損失に追従しながらも、少し上に位置している。

3. **Full Validation Lossのポイント**（赤い点）  
   - 赤い点が示す**Full validation loss**は検証損失のトレンドを反映しつつ、わずかに低い値で安定している。

---

### **総合評価**
1. **過学習の程度**  
   - **過学習は軽微**と判断できる。トレーニング損失と検証損失の差が小さく、完全な検証損失も安定しているため。

2. **汎化性能**  
   - モデルは学習データと検証データの両方で良好な性能を発揮している。  
   - **Full validation loss**が検証損失よりも低いため、モデルの汎化性能は一定の信頼性がある。

---

### **結論**
- **モデルは十分に良い状態**であり、過学習の兆候は軽微。  
- Full validation lossが安定しているため、モデルの汎化性能も問題ない。  

---

※validation loss < train lossの場合  
1. 正規化には、training時がけ適用されるものがある。  
2. training lossは1エポック中計算され、validationは1エポック終了時に計算される。  
3. validationに、trainingより簡単なデータが集まっている。(サンプルの偏りがある)

loss 収束0.1以下が目安

# 12/21(Sat)
アセンブリコードをCコードに変換してくれるLLMの出力を以下に示す。内容はpolybenchである。

<details><summary>2mm</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
/* Include polybench common header. */
#include <polybench.h>
/* Include benchmark-specific header. */
#include "2mm.h"
/* Array initialization. */
static
void init_array(int ni, int nj, int nk, int nl,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),
		DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),
		DATA_TYPE POLYBENCH_2D(D,NJ,NL,nj,nl))
{
  int i, j;
  *alpha = 1.5;
  *beta = 1.2;
  for (i = 0; i < ni; i++)
    for (j = 0; j < nj; j++)
      C[i][j] = (DATA_TYPE) (i*j % ni) / ni;
  for (i = 0; i < ni; i++)
    for (j = 0; j < nk; j++)
      A[i][j] = (DATA_TYPE) ((i*(j+1)) % nk) / nk;
  for (i = 0; i < nk; i++)
    for (j = 0; j < nj; j++)
      B[i][j] = (DATA_TYPE) (i*(j+2) % nj) / nj;
  for (i = 0; i < nj; i++)
    for (j = 0; j < nl; j++)
      D[i][j] = (DATA_TYPE) ((i*(j+2)) % nl) / nl;
}
/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int ni, int nl,
		 DATA_TYPE POLYBENCH_2D(G,NI,NL,ni,nl))
{
  int i, j;
  POLYBENCH_DUMP_BEGIN("G");
  for (i = 0; i < ni; i++) {
    for (j = 0; j < nl; j++) {
	if ((i * ni + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "
");
	fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, G[i][j]);
    }
  }
  POLYBENCH_DUMP_END("G");
}
/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static
void kernel_2mm(int ni, int nj, int nk, int nl,
		DATA_TYPE alpha,
		DATA_TYPE beta,
		DATA_TYPE POLYBENCH_2D(tmp,NI,NJ,ni,nj),
		DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),
		DATA_TYPE POLYBENCH_2D(C,NJ,NL,nj,nl),
		DATA_TYPE POLYBENCH_2D(D,NI,NL,ni,nl))
{
  int i, j, k;
#pragma scop
  for (i = 0; i < _PB_NI; i++)
    for (j = 0; j < _PB_NJ; j++) {
	tmp[i][j] = SCALAR_VAL(0.0);
	for (k = 0; k < _PB_NK; ++k)
	  tmp[i][j] += alpha * A[i][k] * B[k][j];
      }
  for (i = 0; i < _PB_NI; i++)
    for (j = 0; j < _PB_NL; j++) {
	D[i][j] *= beta;
	for (k = 0; k < _PB_NJ; ++k)
	  D[i][j] += tmp[i][k] * C[k][j];
      }
#pragma endscop
}
int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int ni = NI;
  int nj = NJ;
  int nk = NK;
  int nl = NL;
  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(C,DATA_TYPE,NI,NJ,ni,nj);
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,NI,NK,ni,nk);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,NK,NJ,nk,nj);
  POLYBENCH_2D_ARRAY_DECL(D,DATA_TYPE,NJ,NL,nj,nl);
  POLYBENCH_2D_ARRAY_DECL(tmp,DATA_TYPE,NI,NJ,ni,nj);
  /* Initialize array(s). */
  init_array (ni, nj, nk, nl, &alpha, &beta,
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B),
	      POLYBENCH_ARRAY(D));
  /* Start timer. */
  polybench_start_instruments;
  /* Run kernel. */
  kernel_2mm (ni, nj, nk, nl, alpha, beta,
	      POLYBENCH_ARRAY(tmp),
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B),
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(D));
  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;
  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(ni, nl, POLYBENCH_ARRAY(D)));
  /* Be clean. */
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
  POLYBENCH_FREE_ARRAY(D);
  POLYBENCH_FREE_ARRAY(tmp);
  return 0;
}
```

</details>

<details><summary>3mm</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "3mm.h"


/* Array initialization. */
static
void init_array (int ni, int nj, int nk, int nl, int nm,
		 DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		 DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),
		 DATA_TYPE POLYBENCH_2D(C,NJ,NM,nj,nm),
		 DATA_TYPE POLYBENCH_2D(D,NM,NL,nm,nl))
{
  int i, j;

  for (i = 0; i < ni; i++)
    for (j = 0; j < nk; j++)
      A[i][j] = (DATA_TYPE) ((i*j+1) % ni) / (5*ni);

  for (i = 0; i < nk; i++)
    for (j = 0; j < nj; j++)
      B[i][j] = (DATA_TYPE) ((i*(j+1)+2) % nj) / (5*nj);

  for (i = 0; i < nj; i++)
    for (j = 0; j < nm; j++)
      C[i][j] = (DATA_TYPE) (i*(j+3) % nl) / (5*nl);

  for (i = 0; i < nm; i++)
    for (j = 0; j < nl; j++)
      D[i][j] = (DATA_TYPE) ((i*(j+2)+2) % nk) / (5*nk);
}


/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */

static
void print_array(int ni, int nl,
		 DATA_TYPE POLYBENCH_2D(G,NI,NL,ni,nl))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("G");
  for (i = 0; i < ni; i++)
    for (j = 0; j < nl; j++) {
      if ((i * ni + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, G[i][j]);
    }
  POLYBENCH_DUMP_END("G");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_3mm(int ni, int nj, int nk, int nl, int nm,
		DATA_TYPE POLYBENCH_2D(E,NI,NJ,ni,nj),
		DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj),
		DATA_TYPE POLYBENCH_2D(F,NJ,NL,nj,nl),
		DATA_TYPE POLYBENCH_2D(C,NJ,NM,nj,nm),
		DATA_TYPE POLYBENCH_2D(D,NM,NL,nm,nl),
		DATA_TYPE POLYBENCH_2D(G,NI,NL,ni,nl))

{
  int i, j, k;

#pragma scop 
    /* E := A*B */
    for (i = 0; i < _PB_NI; i++)
      for (j = 0; j < _PB_NJ; j++)
	{
	  E[i][j] = SCALAR_VAL(0.0);
	  for (k = 0; k < _PB_NK; ++k)
	    E[i][j] += A[i][k] * B[k][j];
	}
    /* F := C*D */
    for (i = 0; i < _PB_NJ; i++)
      for (j = 0; j < _PB_NL; j++)
	{
	  F[i][j] = SCALAR_VAL(0.0);
	  for (k = 0; k < _PB_NM; ++k)
	    F[i][j] += C[i][k] * D[k][j];
	}
    /* G := E*F */
    for (i = 0; i < _PB_NI; i++)
      for (j = 0; j < _PB_NL; j++)
	{
	  G[i][j] = SCALAR_VAL(0.0);
	  for (k = 0; k < _PB_NJ; ++k)
	    G[i][j] += E[i][k] * F[k][j];
	}
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int ni = NI;
  int nj = NJ;
  int nk = NK;
  int nl = NL;
  int nm = NM;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(E,DATA_TYPE,NI,NJ,ni,nj);
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,NI,NK,ni,nk);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,NK,NJ,nk,nj);
  POLYBENCH_2D_ARRAY_DECL(F,DATA_TYPE,NJ,NL,nj,nl);
  POLYBENCH_2D_ARRAY_DECL(C,DATA_TYPE,NJ,NM,nj,nm);
  POLYBENCH_2D_ARRAY_DECL(D,DATA_TYPE,NM,NL,nm,nl);
  POLYBENCH_2D_ARRAY_DECL(G,DATA_TYPE,NI,NL,ni,nl);

  /* Initialize array(s). */
  init_array (ni, nj, nk, nl, nm,
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B),
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(D));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_3mm (ni, nj, nk, nl, nm,
	      POLYBENCH_ARRAY(E),
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B),
	      POLYBENCH_ARRAY(F),
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(D),
	      POLYBENCH_ARRAY(G));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(ni, nl, POLYBENCH_ARRAY(G)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(E);
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
  POLYBENCH_FREE_ARRAY(F);
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(D);
  POLYBENCH_FREE_ARRAY(G);

  return 0;
}
```

</details>

<details><summary>adi</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* adi.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "adi.h"

/* Array initialization. */
static void init_array(int n,
                       DATA_TYPE POLYBENCH_2D(U, N, N, n, n),
                       DATA_TYPE POLYBENCH_2D(V, N, N, n, n),
                       DATA_TYPE POLYBENCH_2D(P, N, N, n, n)) {
  int i, j;
  DATA_TYPE fn = (DATA_TYPE)n;

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      U[i][j] = (DATA_TYPE)(i + n - j) / n;
      V[i][j] = (DATA_TYPE)(n - j + 1) / n;
      P[i][j] = (DATA_TYPE)(i + n - j) / n;
    }
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n,
                        DATA_TYPE POLYBENCH_2D(U, N, N, n, n)) {
  int i, j;

  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("U");

  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      if ((i * n + j) % 20 == 0)
        fprintf(POLYBENCH_DUMP_TARGET, "\n");
      fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, U[i][j]);
    }

  POLYBENCH_DUMP_END("U");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_adi(int tsteps, int n,
                       DATA_TYPE POLYBENCH_2D(U, N, N, n, n),
                       DATA_TYPE POLYBENCH_2D(V, N, N, n, n),
                       DATA_TYPE POLYBENCH_2D(P, N, N, n, n)) {
  int t, i, j;
  DATA_TYPE DX, DY, DT;
  DATA_TYPE B1, B2;
  DATA_TYPE mul1, mul2;
  DATA_TYPE a, b, c, d, e, f;

  DX = 1.0 / (DATA_TYPE)_PB_N;
  DY = 1.0 / (DATA_TYPE)_PB_N;
  DT = 1.0 / (DATA_TYPE)_PB_TSTEPS;
  B1 = 2.0;
  B2 = 1.0;
  mul1 = B1 * DT / (DX * DX);
  mul2 = B2 * DT / (DY * DY);
  a = -mul1 / 2.0;
  b = 1.0 + mul1;
  c = a;
  d = -mul2 / 2.0;
  e = 1.0 + mul2;
  f = d;

#pragma scop
  for (t = 1; t <= _PB_TSTEPS; t++) {
    // Column Sweep
    for (i = 0; i < _PB_N; i++) {
      V[0][i] = 1.0;
      P[i][0] = 0.0;
      for (j = 1; j < _PB_N - 1; j++) {
        P[i][j] = (d * V[j - 1][i] + e * V[j][i] + f * V[j + 1][i] - P[i][j - 1]) / b;
      }
      P[i][_PB_N - 1] = 1.0;
      V[_PB_N - 1][i] = 0.0;
      for (j = _PB_N - 2; j >= 1; j--) {
        V[j][i] = P[i][j] - c * V[j + 1][i] / b;
      }
    }

    // ROW SWEEP
    for (i = 0; i < _PB_N; i++) {
      U[i][0] = 1.0;
      P[0][i] = 0.0;
      for (j = 1; j < _PB_N - 1; j++) {
        P[j][i] = (a * U[i][j - 1] + b * U[i][j] + c * U[i][j + 1] - P[j - 1][i]) / e;
      }
      P[_PB_N - 1][i] = 1.0;
      U[i][_PB_N - 1] = 0.0;
      for (j = _PB_N - 2; j >= 1; j--) {
        U[i][j] = P[j][i] - f * U[i][j + 1] / e;
      }
    }
  }
#pragma endscop
}

int main(int argc, char **argv) {
  /* Retrieve problem size. */
  int n = N;
  int tsteps = TSTEPS;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(U, DATA_TYPE, N, N, n, n);
  POLYBENCH_2D_ARRAY_DECL(V, DATA_TYPE, N, N, n, n);
  POLYBENCH_2D_ARRAY_DECL(P, DATA_TYPE, N, N, n, n);

  /* Initialize array(s). */
  init_array(n, POLYBENCH_ARRAY(U), POLYBENCH_ARRAY(V), POLYBENCH_ARRAY(P));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_adi(tsteps, n, POLYBENCH_ARRAY(U), POLYBENCH_ARRAY(V), POLYBENCH_ARRAY(P));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(U)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(U);
  POLYBENCH_FREE_ARRAY(V);
  POLYBENCH_FREE_ARRAY(P);

  return 0;
}
```

</details>

<details><summary>atax</summary>

```c
/** * This version is stamped on May 10, 2016 * * Contact: *   Louis-Noel Pouchet <pouchet.ohio-state.edu> *   Tomofumi Yuki <tomofumi.yuki.fr> * * Web address: http://polybench.sourceforge.net *//* atax.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "atax.h"

/* Array initialization. */
static void init_array(int m, int n,
	DATA_TYPE POLYBENCH_2D(A, M, N, m, n),
	DATA_TYPE POLYBENCH_1D(x, N, n)) {
	int i, j;
	for (i = 0; i < n; i++) {
		x[i] = i * M_PI;
	}
	for (i = 0; i < m; i++) {
		for (j = 0; j < n; j++) {
			A[i][j] = ((DATA_TYPE)i * (j)) / M;
		}
	}
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n,
	DATA_TYPE POLYBENCH_1D(y, N, n)) {
	int i;
	POLYBENCH_DUMP_START;
	POLYBENCH_DUMP_BEGIN("y");
	for (i = 0; i < n; i++) {
		if (i % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "
");
		fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, y[i]);
	}
	POLYBENCH_DUMP_END("y");
	POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_atax(int m, int n,
	DATA_TYPE POLYBENCH_2D(A, M, N, m, n),
	DATA_TYPE POLYBENCH_1D(x, N, n),
	DATA_TYPE POLYBENCH_1D(y, N, n),
	DATA_TYPE POLYBENCH_1D(tmp, M, m)) {
	int i, j;

#pragma scop
	for (i = 0; i < _PB_N; i++)
		y[i] = 0;
	for (i = 0; i < _PB_M; i++)
	{
		tmp[i] = SCALAR_VAL(0.0);
		for (j = 0; j < _PB_N; j++)
			tmp[i] = tmp[i] + A[i][j] * x[j];
		for (j = 0; j < _PB_N; j++)
			y[j] = y[j] + A[i][j] * tmp[i];
	}
#pragma endscop
}

int main(int argc, char** argv) {
	/* Retrieve problem size. */
	int m = M;
	int n = N;

	/* Variable declaration/allocation. */
	POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, M, N, m, n);
	POLYBENCH_1D_ARRAY_DECL(x, DATA_TYPE, N, n);
	POLYBENCH_1D_ARRAY_DECL(y, DATA_TYPE, N, n);
	POLYBENCH_1D_ARRAY_DECL(tmp, DATA_TYPE, M, m);

	/* Initialize array(s). */
	init_array(m, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(x));

	/* Start timer. */
	polybench_start_instruments;

	/* Run kernel. */
	kernel_atax(m, n,
		POLYBENCH_ARRAY(A),
		POLYBENCH_ARRAY(x),
		POLYBENCH_ARRAY(y),
		POLYBENCH_ARRAY(tmp));

	/* Stop and print timer. */
	polybench_stop_instruments;
	polybench_print_instruments;

	/* Prevent dead-code elimination. All live-out data must be printed
	   by the function call in argument. */
	polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(y)));

	/* Be clean. */
	POLYBENCH_FREE_ARRAY(A);
	POLYBENCH_FREE_ARRAY(x);
	POLYBENCH_FREE_ARRAY(y);
	POLYBENCH_FREE_ARRAY(tmp);

	return 0;
}
```

</details>

<details><summary>bicg</summary>

```c
/**
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "bicg.h"

/* Array initialization. */
static void init_array(int m, int n,
                       DATA_TYPE POLYBENCH_1D(A, N, n),
                       DATA_TYPE POLYBENCH_1D(r, N, n),
                       DATA_TYPE POLYBENCH_1D(p, M, m),
                       DATA_TYPE POLYBENCH_2D(A, N, M, n, m)) {
  int i, j;

  for (i = 0; i < n; i++) {
    r[i] = (DATA_TYPE)(i * M_PI);
    for (j = 0; j < m; j++)
      A[i][j] = (DATA_TYPE)((i * (j)) % m) / m;
  }
  for (i = 0; i < m; i++)
    p[i] = (DATA_TYPE)(i * M_PI);
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int m,
                        DATA_TYPE POLYBENCH_1D(s, M, m),
                        DATA_TYPE POLYBENCH_1D(q, N, n)) {
  int i;

  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("s");
  for (i = 0; i < m; i++) {
    if (i % 20 == 0)
      fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, s[i]);
  }
  POLYBENCH_DUMP_END("s");

  POLYBENCH_DUMP_BEGIN("q");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0)
      fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, q[i]);
  }
  POLYBENCH_DUMP_END("q");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_bicg(int m, int n,
                        DATA_TYPE POLYBENCH_1D(s, M, m),
                        DATA_TYPE POLYBENCH_1D(q, N, n),
                        DATA_TYPE POLYBENCH_1D(p, M, m),
                        DATA_TYPE POLYBENCH_1D(r, N, n),
                        DATA_TYPE POLYBENCH_2D(A, N, M, n, m)) {
  int i, j;

  DATA_TYPE temp_q[N];
  DATA_TYPE temp_s[M];

  temp_q[0 : N] = 0;
  temp_s[0 : M] = 0;

#pragma omp parallel for
  for (i = 0; i < N; i++) {
    for (j = 0; j < M; j++)
      temp_q[i] = temp_q[i] + A[i][j] * p[j];
  }
#pragma omp parallel for
  for (j = 0; j < M; j++) {
    for (i = 0; i < N; i++)
      temp_s[j] = temp_s[j] + A[i][j] * r[i];
  }

  s[0 : M] = temp_s[0 : M];
  q[0 : N] = temp_q[0 : N];
}

int main(int argc, char **argv) {
  /* Retrieve problem size. */
  int m = M;
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_1D_ARRAY_DECL(s, DATA_TYPE, M, m);
  POLYBENCH_1D_ARRAY_DECL(q, DATA_TYPE, N, n);
  POLYBENCH_1D_ARRAY_DECL(p, DATA_TYPE, M, m);
  POLYBENCH_1D_ARRAY_DECL(r, DATA_TYPE, N, n);
  POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, N, M, n, m);

  /* Initialize array(s). */
  init_array(m, n,
             POLYBENCH_ARRAY(A),
             POLYBENCH_ARRAY(r),
             POLYBENCH_ARRAY(p),
             POLYBENCH_ARRAY(A));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_bicg(m, n,
              POLYBENCH_ARRAY(s),
              POLYBENCH_ARRAY(q),
              POLYBENCH_ARRAY(p),
              POLYBENCH_ARRAY(r),
              POLYBENCH_ARRAY(A));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
    by the function call in argument. */
  polybench_prevent_dce(print_array(m, POLYBENCH_ARRAY(s), POLYBENCH_ARRAY(q)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(s);
  POLYBENCH_FREE_ARRAY(q);

  return 0;
}
```

</details>

<details><summary>cholesky</summary>

```c
/**
 * This version is stamped on May 10, 2016.
 * 
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 * 
 * Web address: http://polybench.sourceforge.net
 */

/* cholesky.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "cholesky.h"

/* Array initialization. */
static void init_array(int n, DATA_TYPE POLYBENCH_2D(A, N, N, n, n)) {
    int i, j;

    for (i = 0; i < n; i++) {
        for (j = 0; j <= i; j++) {
            A[i][j] = (DATA_TYPE)(-j % n) / n + 1;
        }
        for (j = i + 1; j < n; j++) {
            A[i][j] = 0;
        }
        A[i][i] = 1;
    }

    /* Make the matrix positive semi-definite. */
    int r, s, t;
    POLYBENCH_2D_ARRAY_DECL(B, DATA_TYPE, N, N, n, n);

    for (r = 0; r < n; ++r)
        for (s = 0; s < n; ++s)
            B[r][s] = 0;

    for (t = 0; t < n; ++t)
        for (r = 0; r < n; ++r)
            for (s = 0; s < n; ++s)
                B[r][s] += A[r][t] * A[s][t];

    for (r = 0; r < n; ++r)
        for (s = 0; s < n; ++s)
            A[r][s] = B[r][s];

    POLYBENCH_FREE_ARRAY(B);
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n, DATA_TYPE POLYBENCH_2D(A, N, N, n, n)) {
    int i, j;

    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("A");

    for (i = 0; i < n; i++) {
        for (j = 0; j <= i; j++) {
            if ((i * n + j) % 20 == 0)
                fprintf(POLYBENCH_DUMP_TARGET, "\n");
            fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
        }
    }

    POLYBENCH_DUMP_END("A");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_cholesky(int n, DATA_TYPE POLYBENCH_2D(A, N, N, n, n)) {
    int i, j, k;

#pragma scop
    for (i = 0; i < _PB_N; i++) {
        for (j = 0; j <= i; j++) {
            DATA_TYPE temp_sum = 0;

            for (k = 0; k < j; k++)
                temp_sum += A[i][k] * A[j][k];

            if (i == j)
                A[i][j] = SQRT_FUN(A[i][i] - temp_sum);
            else
                A[i][j] = (1.0 / A[j][j] * (A[i][j] - temp_sum));
        }
    }
#pragma endscop
}

int main(int argc, char** argv) {
    /* Retrieve problem size. */
    int n = N;

    /* Variable declaration/allocation. */
    POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, N, N, n, n);

    /* Initialize array(s). */
    init_array(n, POLYBENCH_ARRAY(A));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_cholesky(n, POLYBENCH_ARRAY(A));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent DCE */
    polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(A);

    return 0;
}

```

</details>

<details><summary>correlation</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

#include <polybench.h>
#include "correlation.h"

/* Array initialization. */
static
void init_array(int m, int n,
		DATA_TYPE *float_n,
		DATA_TYPE POLYBENCH_2D(data,N,M,n,m))
{
  int i, j;

  *float_n = (DATA_TYPE)LARGE_FLOAT_N;
  DATA_TYPE fn = (DATA_TYPE)LARGE_FLOAT_N;

  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      data[i][j] = ((DATA_TYPE)i*j) / m + i;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output.
   After SCOP, all live-out data must be printed using this function to
   avoid dead-code elimination. */
static
void print_array(int m, DATA_TYPE POLYBENCH_2D(corr,M,M,m,m)) 
{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("corr");
  for (i = 0; i < m; i++)
    for (j = 0; j < m; j++)
       if (i < j && (j-i) < 12) {
	  if ((i*m+j) % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
	  fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, corr[i][j]);
       }
  POLYBENCH_DUMP_END("corr");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_correlation(int m, int n,
	       DATA_TYPE float_n,
	       DATA_TYPE POLYBENCH_2D(data,N,M,n,m),
	       DATA_TYPE POLYBENCH_1D(mean,M,m),
	       DATA_TYPE POLYBENCH_1D(stddev,M,m),
	       DATA_TYPE POLYBENCH_2D(corr,M,M,m,m))
{
  int i, j, k;

  DATA_TYPE eps = SCALAR_VAL(0.1);

#pragma scop
  for (i = 0; i < _PB_M; i++)
    {
      mean[i] = SCALAR_VAL(0.0);
      for (j = 0; j < _PB_N; j++)
	mean[i] += data[j][i];
      mean[i] /= float_n;
    }


  for (i = 0; i < _PB_M; i++) {
      stddev[i] = SCALAR_VAL(0.0);
      for (j = 0; j < _PB_N; j++)
	stddev[i] += (data[j][i] - mean[i]) * (data[j][i] - mean[i]);
      stddev[i] /= float_n;
      stddev[i] = SQRT_FUN(stddev[i]);
      /* The following in an inelegant but usual way to handle
	 near-zero std. dev. values, which below would cause a zero-
	 divide. */
      stddev[i] = stddev[i] <= eps ? SCALAR_VAL(1.0) : stddev[i];
    }

  
  /* Center and reduce the column vectors. */
  for (i = 0; i < _PB_N; i++)
    for (j = 0; j < _PB_M; j++) {
        data[i][j] -= mean[j];
        data[i][j] /= SQRT_FUN(float_n)*stddev[j];
    }

  
  /* Calculate the m * m correlation matrix. */
  for (i = 0; i < _PB_M-1; i++) {
    corr[i][i] = SCALAR_VAL(1.0);
    for (j = i+1; j < _PB_M; j++) {
      corr[i][j] = SCALAR_VAL(0.0);
      for (k = 0; k < _PB_N; k++)
        corr[i][j] += (data[k][i] * data[k][j]);
      corr[j][i] = corr[i][j];
     }
  }
  corr[_PB_M-1][_PB_M-1] = SCALAR_VAL(1.0);
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int m = M;

  /* Variable declaration/allocation. */
  DATA_TYPE float_n;
  POLYBENCH_2D_ARRAY_DECL(data, DATA_TYPE, N, M, n, m);
  POLYBENCH_1D_ARRAY_DECL(mean, DATA_TYPE, M, m);
  POLYBENCH_1D_ARRAY_DECL(stddev, DATA_TYPE, M, m);
  POLYBENCH_2D_ARRAY_DECL(corr, DATA_TYPE, M, M, m, m);
  

  /* Initialize array(s). */
  init_array (m, n, &float_n,
	      POLYBENCH_ARRAY(data));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_correlation (m, n, float_n,
	     POLYBENCH_ARRAY(data),
	     POLYBENCH_ARRAY(mean),
	     POLYBENCH_ARRAY(stddev),
	     POLYBENCH_ARRAY(corr));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(m, POLYBENCH_ARRAY(corr)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(data);
  POLYBENCH_FREE_ARRAY(mean);
  POLYBENCH_FREE_ARRAY(stddev);
  POLYBENCH_FREE_ARRAY(corr);

  return 0;
}
```

</details>

<details><summary>covariance</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

#include <polybench.h>
#include "covariance.h"

/* Array initialization. */
static
void init_array(int m, int n,
		DATA_TYPE *float_n,
		DATA_TYPE POLYBENCH_2D(data,N,M,n,m))
{
  int i, j;

  *float_n = (DATA_TYPE)LARGE_FLOAT_N;
  DATA_TYPE fn = (DATA_TYPE)LARGE_FLOAT_N;

  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      data[i][j] = ((DATA_TYPE)i*j) / m + i;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output.
   After SCOP, all live-out data must be printed using this function to
   avoid dead-code elimination. */
static
void print_array(int m, DATA_TYPE POLYBENCH_2D(cov,M,M,m,m))
{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("cov");
  for (i = 0; i < m; i++) {
    for (j = 0; j <= i; j++) {
      if ((i*m+j) % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
      fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, cov[i][j]);
    }
  }
  POLYBENCH_DUMP_END("cov");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_covariance(int m, int n,
		       DATA_TYPE float_n,
		       DATA_TYPE POLYBENCH_2D(data,N,M,n,m),
		       DATA_TYPE POLYBENCH_1D(mean,M,m),
		       DATA_TYPE POLYBENCH_2D(cov,M,M,m,m))
{
  int i, j, k;
  
#pragma scop
  for (j = 0; j < _PB_M; j++)
    {
      mean[j] = SCALAR_VAL(0.0);
      for (i = 0; i < _PB_N; i++)
	mean[j] += data[i][j];
      mean[j] /= float_n;
    }

  for (i = 0; i < _PB_N; i++)
    for (j = 0; j < _PB_M; j++)
      data[i][j] -= mean[j];

  for (i = 0; i < _PB_M; i++)
    for (j = i; j < _PB_M; j++)
      {
	cov[i][j] = SCALAR_VAL(0.0);
	for (k = 0; k < _PB_N; k++) {
	   cov[i][j] += data[k][i] * data[k][j];
	}
	cov[i][j] /= (float_n-1.0);
	cov[j][i] = cov[i][j];
      }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int m = M;

  /* Variable declaration/allocation. */
  DATA_TYPE float_n;
  POLYBENCH_2D_ARRAY_DECL(data, DATA_TYPE, N, M, n, m);
  POLYBENCH_1D_ARRAY_DECL(mean, DATA_TYPE, M, m);
  POLYBENCH_2D_ARRAY_DECL(cov, DATA_TYPE, M, M, m, m);

  /* Initialize array(s). */
  init_array (m, n, &float_n,
	      POLYBENCH_ARRAY(data));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_covariance (m, n, float_n,
	     POLYBENCH_ARRAY(data),
	     POLYBENCH_ARRAY(mean),
	     POLYBENCH_ARRAY(cov));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(m, POLYBENCH_ARRAY(cov)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(data);
  POLYBENCH_FREE_ARRAY(mean);
  POLYBENCH_FREE_ARRAY(cov);

  return 0;
}
```

</details>

<details><summary>deriche</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "deriche.h"

/* Array initialization. */
static
void init_array(int w, int h,
		DATA_TYPE *alpha,
		DATA_TYPE POLYBENCH_2D(imgIn,W,H,w,h),
		DATA_TYPE POLYBENCH_2D(imgOut,W,H,w,h))
{
  int i, j;

  *alpha=0.25; //parameter to be tuned

  /* assumed to live in [0..1] */
  for (i = 0; i < w; i++)
    for (j = 0; j < h; j++)
      {
	imgIn[i][j] = (DATA_TYPE)(313*i+991*j)%65536 / 65535.0f;
	imgOut[i][j] = ZERO;
      }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int w, int h,
		 DATA_TYPE POLYBENCH_2D(imgOut,W,H,w,h))
{
  int i, j;

  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("imgOut");
  for (i = 0; i < w; i++)
    for (j = 0; j < h; j++) {
      if ((i*h+j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, imgOut[i][j]);
    }
  POLYBENCH_DUMP_END("imgOut");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_deriche(int w, int h, DATA_TYPE alpha,
       DATA_TYPE POLYBENCH_2D(imgIn, W, H, w, h),
       DATA_TYPE POLYBENCH_2D(imgOut, W, H, w, h),
       DATA_TYPE POLYBENCH_2D(y1, W, H, w, h),
       DATA_TYPE POLYBENCH_2D(y2, W, H, w, h))
{
  int i, j;
  DATA_TYPE xm1, tm1, ym1, ym2;
  DATA_TYPE xp1, xp2, tp1, tp2;
  DATA_TYPE yp1, yp2;
  DATA_TYPE k;
  DATA_TYPE a1, a2, a3, a4, b1, b2, c1, c2;
  DATA_TYPE coef[4];

/* 1-D buffers to store computation of each row   */
  DATA_TYPE *buffer = malloc(W * sizeof(DATA_TYPE));
  
#pragma scop

  k = (SCALAR_VAL(1.0)-EXP_FUN(-alpha))*(SCALAR_VAL(1.0)-EXP_FUN(-alpha))/(SCALAR_VAL(1.0)+SCALAR_VAL(2.0)*alpha*EXP_FUN(-alpha)-EXP_FUN(SCALAR_VAL(2.0)*alpha));
  a1 = a5 = k;
  a2 = a6 = k*EXP_FUN(-alpha)*(alpha-SCALAR_VAL(1.0));
  a3 = a7 = k*EXP_FUN(-alpha)*(alpha+SCALAR_VAL(1.0));
  a4 = a8 = -k*EXP_FUN(SCALAR_VAL(-2.0)*alpha);
  b1 =  POW_FUN(SCALAR_VAL(2.0), -alpha);
  b2 = -EXP_FUN(SCALAR_VAL(-2.0)*alpha);
  c1 = c2 = 1;

  //y1 = malloc(sizeof(DATA_TYPE) * w * h);
  //y2 = malloc(sizeof(DATA_TYPE) * w * h);

  /* N-S horizontal pass */
  for (i=0; i<_PB_W; i++) { 
      ym1 = SCALAR_VAL(0.0);
      ym2 = SCALAR_VAL(0.0);
      xm1 = SCALAR_VAL(0.0);
      for (j=0; j<_PB_H; j++) {
          y1[i][j] = a1*imgIn[i][j] + a2*xm1 + b1*ym1 + b2*ym2;
          xm1 = imgIn[i][j];
          ym2 = ym1;
          ym1 = y1[i][j];
      }
  }

  /* S-N horizontal pass */
  for (i=0; i<_PB_W; i++) {
      yp1 = SCALAR_VAL(0.0);
      yp2 = SCALAR_VAL(0.0);
      xp1 = SCALAR_VAL(0.0);
      xp2 = SCALAR_VAL(0.0);
      for (j=_PB_H-1; j>=0; j--) {
          y2[i][j] = a3*xp1 + a4*xp2 + b1*yp1 + b2*yp2;
          xp2 = xp1;
          xp1 = imgIn[i][j];
          yp2 = yp1;
          yp1 = y2[i][j];
      }
  }

  for (i=0; i<_PB_W; i++)
      for (j=0; j<_PB_H; j++) {
          imgOut[i][j] = c1*(y1[i][j] + y2[i][j]);
      }

  /* W-E vertical pass */
  for (j=0; j<_PB_H; j++) {
      tm1 = SCALAR_VAL(0.0);
      ym1 = SCALAR_VAL(0.0);
      ym2 = SCALAR_VAL(0.0);
      for (i=0; i<_PB_W; i++) {
          y1[i][j] = a5*imgOut[i][j] + a6*tm1 + b1*ym1 + b2*ym2;
          tm1 = imgOut[i][j];
          ym2 = ym1;
          ym1 = y1[i][j];
      }
  }

  /* E-W Vertical pass */
  for (j=0; j<_PB_H; j++) {
      tp1 = SCALAR_VAL(0.0);
      tp2 = SCALAR_VAL(0.0);
      yp1 = SCALAR_VAL(0.0);
      yp2 = SCALAR_VAL(0.0);
      for (i=_PB_W-1; i>=0; i--) {
          y2[i][j] = a7*tp1 + a8*tp2 + b1*yp1 + b2*yp2;
          tp2 = tp1;
          tp1 = imgOut[i][j];
          yp2 = yp1;
          yp1 = y2[i][j];
      }
  }

  for (i=0; i<_PB_W; i++)    
      for (j=0; j<_PB_H; j++)
          imgOut[i][j] = c2*(y1[i][j] + y2[i][j]);
#pragma endscop
}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int w = W;
  int h = H;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  POLYBENCH_2D_ARRAY_DECL(imgIn, DATA_TYPE, W, H, w, h);
  POLYBENCH_2D_ARRAY_DECL(imgOut, DATA_TYPE, W, H, w, h);
  POLYBENCH_2D_ARRAY_DECL(y1, DATA_TYPE, W, H, w, h);
  POLYBENCH_2D_ARRAY_DECL(y2, DATA_TYPE, W, H, w, h);

  /* Initialize array(s). */
  init_array (w, h, &alpha,
	      POLYBENCH_ARRAY(imgIn),
	      POLYBENCH_ARRAY(imgOut));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_deriche (w, h, alpha,
	    POLYBENCH_ARRAY(imgIn),
	    POLYBENCH_ARRAY(imgOut),
	    POLYBENCH_ARRAY(y1),
	    POLYBENCH_ARRAY(y2));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(w, h, POLYBENCH_ARRAY(imgOut)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(imgIn);
  POLYBENCH_FREE_ARRAY(imgOut);
  POLYBENCH_FREE_ARRAY(y1);
  POLYBENCH_FREE_ARRAY(y2);

  return 0;
}
```

</details>

<details><summary>doitgen</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* doitgen.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "doitgen.h"

/* Array initialization. */
static void init_array(int nr, int nq, int np,
                       DATA_TYPE POLYBENCH_3D(A, NR, NQ, NP, nr, nq, np),
                       DATA_TYPE POLYBENCH_2D(C4, NP, NP, np, np)) {
    int i, j, k;
    for (i = 0; i < nr; i++)
        for (j = 0; j < nq; j++)
            for (k = 0; k < np; k++)
                A[i][j][k] = (DATA_TYPE)((i * j + k) % np) / np;

    for (i = 0; i < np; i++)
        for (j = 0; j < np; j++)
            C4[i][j] = (DATA_TYPE)(i * j % np) / np;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int nr, int nq, int np,
                        DATA_TYPE POLYBENCH_3D(A, NR, NQ, NP, nr, nq, np)) {
    int i, j, k;
    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("A");
    for (i = 0; i < nr; i++)
        for (j = 0; j < nq; j++)
            for (k = 0; k < np; k++) {
                if ((i * nq * np + j * np + k) % 20 == 0)
                    fprintf(POLYBENCH_DUMP_TARGET, "\n");
                fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j][k]);
            }
    POLYBENCH_DUMP_END("A");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_doitgen(int nr, int nq, int np,
                           DATA_TYPE POLYBENCH_3D(A, NR, NQ, NP, nr, nq, np),
                           DATA_TYPE POLYBENCH_2D(C4, NP, NP, np, np),
                           DATA_TYPE POLYBENCH_1D(sum, NP, np)) {
    int r, q, p, s;
#pragma scop
    for (r = 0; r < _PB_NR; r++)
        for (q = 0; q < _PB_NQ; q++) {
            for (p = 0; p < _PB_NP; p++) {
                sum[p] = (DATA_TYPE)0;
                for (s = 0; s < _PB_NP; s++)
                    sum[p] += A[r][q][s] * C4[s][p];
            }
            for (p = 0; p < _PB_NP; p++)
                A[r][q][p] = sum[p];
        }
#pragma endscop
}

int main(int argc, char **argv) {
    /* Retrieve problem size. */
    int nr = NR;
    int nq = NQ;
    int np = NP;

    /* Variable declaration/allocation. */
    POLYBENCH_3D_ARRAY_DECL(A, DATA_TYPE, NR, NQ, NP, nr, nq, np);
    POLYBENCH_2D_ARRAY_DECL(C4, DATA_TYPE, NP, NP, np, np);
    POLYBENCH_1D_ARRAY_DECL(sum, DATA_TYPE, NP, np);

    /* Initialize array(s). */
    init_array(nr, nq, np, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(C4));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_doitgen(nr, nq, np, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(C4), POLYBENCH_ARRAY(sum));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination. All live-out data must be printed
       by the function call in argument. */
    polybench_prevent_dce(print_array(nr, nq, np, POLYBENCH_ARRAY(A)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(A);
    POLYBENCH_FREE_ARRAY(C4);
    POLYBENCH_FREE_ARRAY(sum);

    return 0;
}
```

</details>

<details><summary>durbin</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#ifndef N
# define N 4000
#endif

#include "durbin.h"

/* Array initialization. */
static void init_array(int n, DATA_TYPE POLYBENCH_1D(r, N, n), DATA_TYPE POLYBENCH_1D(y, N, n)) {
    int i, j;
    for (i = 0; i < n; i++) {
        y[i] = (n + 1) / 2.0;
        r[i] = (n + 1) / 2.0;
    }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n, DATA_TYPE POLYBENCH_1D(y, N, n)) {
    int i;
    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("y");
    for (i = 0; i < n; i++) {
        if (i % 20 == 0) 
            fprintf(POLYBENCH_DUMP_TARGET, "\n");
        fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, y[i]);
    }
    POLYBENCH_DUMP_END("y");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel.
   The whole function will be timed, including the call and return. */
static void kernel_durbin(int n, DATA_TYPE POLYBENCH_1D(r, N, n), DATA_TYPE POLYBENCH_1D(y, N, n)) {
    int i, k;
    DATA_TYPE sum;
    DATA_TYPE alpha;
    DATA_TYPE beta;
    DATA_TYPE z[N];
    DATA_TYPE y_2[N];

#pragma scop
    y[0] = -r[0];
    beta = SCALAR_VAL(1.0);
    alpha = -r[0];

    for (k = 1; k < n; k++) {
        beta = (SCALAR_VAL(1.0) - alpha * alpha) * beta;
        sum = SCALAR_VAL(0.0);

        for (i = 0; i < k; i++) {
            sum += r[k - i - 1] * y[i];
        }

        alpha = -(r[k] + sum) / beta;

        for (i = 0; i < k; i++) {
            y_2[i] = y[i];
        }

        for (i = 0; i < k; i++) {
            y[i] = alpha * y_2[k - i - 1] + y_2[i];
        }

        y[k] = alpha;
    }
#pragma endscop
}

int main(int argc, char** argv) {
    /* Retrieve problem size. */
    int n = N;

    /* Variable declaration/allocation. */
    POLYBENCH_1D_ARRAY_DECL(r, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(y, DATA_TYPE, N, n);

    /* Initialize array(s). */
    init_array(n, POLYBENCH_ARRAY(r), POLYBENCH_ARRAY(y));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_durbin(n, POLYBENCH_ARRAY(r), POLYBENCH_ARRAY(y));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination.
       All live-out data must be printed by the function call in argument. */
    polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(y)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(r);
    POLYBENCH_FREE_ARRAY(y);

    return 0;
}

```

</details>

<details><summary>fdtd-2d</summary>

```c
/**
 * This version is stamped on May 10, 2016
 * 
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 * 
 * Web address: http://polybench.sourceforge.net
 *
 * fdtd-2d.c: this file is part of PolyBench/C
 */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "fdtd-2d.h"

/* Array initialization. */
static void init_array(
    int tmax, int nx, int ny,
    DATA_TYPE POLYBENCH_2D(ex, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(ey, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(hz, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_1D(_fict_, TMAX, tmax)) {
  
    int i, j;

    for (i = 0; i < tmax; i++) {
        _fict_[i] = (DATA_TYPE)i;
    }

    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny; j++) {
            ex[i][j] = ((DATA_TYPE)i * (j + 1)) / nx;
            ey[i][j] = ((DATA_TYPE)i * (j + 2)) / ny;
            hz[i][j] = ((DATA_TYPE)i * (j + 3)) / nx;
        }
    }
}

/* DCE code. Must scan the entire live-out data. 
   Can be used also to check the correctness of the output. */
static void print_array(
    int nx, int ny,
    DATA_TYPE POLYBENCH_2D(ex, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(ey, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(hz, NX, NY, nx, ny)) {
  
    int i, j;

    POLYBENCH_DUMP_START;

    // Print 'ex' array
    POLYBENCH_DUMP_BEGIN("ex");
    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny; j++) {
            if ((i * ny + j) % 20 == 0) {
                fprintf(POLYBENCH_DUMP_TARGET, "\n");
            }
            fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, ex[i][j]);
        }
    }
    POLYBENCH_DUMP_END("ex");

    // Print 'ey' array
    POLYBENCH_DUMP_BEGIN("ey");
    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny; j++) {
            if ((i * ny + j) % 20 == 0) {
                fprintf(POLYBENCH_DUMP_TARGET, "\n");
            }
            fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, ey[i][j]);
        }
    }
    POLYBENCH_DUMP_END("ey");

    // Print 'hz' array
    POLYBENCH_DUMP_BEGIN("hz");
    for (i = 0; i < nx; i++) {
        for (j = 0; j < ny; j++) {
            if ((i * ny + j) % 20 == 0) {
                fprintf(POLYBENCH_DUMP_TARGET, "\n");
            }
            fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, hz[i][j]);
        }
    }
    POLYBENCH_DUMP_END("hz");

    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed, 
   including the call and return. */
static void kernel_fdtd_2d(
    int tmax, int nx, int ny,
    DATA_TYPE POLYBENCH_2D(ex, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(ey, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_2D(hz, NX, NY, nx, ny),
    DATA_TYPE POLYBENCH_1D(_fict_, TMAX, tmax)) {
  
    int t, i, j;

#pragma scop
    for (t = 0; t < tmax; t++) {
        for (j = 0; j < ny; j++) {
            ey[0][j] = _fict_[t];
        }

        for (i = 1; i < nx; i++) {
            for (j = 0; j < ny; j++) {
                ey[i][j] = ey[i][j] - SCALAR_VAL(0.5) * (hz[i][j] - hz[i - 1][j]);
            }
        }

        for (i = 0; i < nx; i++) {
            for (j = 1; j < ny; j++) {
                ex[i][j] = ex[i][j] - SCALAR_VAL(0.5) * (hz[i][j] - hz[i][j - 1]);
            }
        }

        for (i = 0; i < nx - 1; i++) {
            for (j = 0; j < ny - 1; j++) {
                hz[i][j] = hz[i][j] - SCALAR_VAL(0.7) *
                           (ex[i][j + 1] - ex[i][j] + ey[i + 1][j] - ey[i][j]);
            }
        }
    }
#pragma endscop
}

int main(int argc, char** argv) {
    /* Retrieve problem size. */
    int tmax = TMAX;
    int nx = NX;
    int ny = NY;

    /* Variable declaration/allocation. */
    POLYBENCH_2D_ARRAY_DECL(ex, DATA_TYPE, NX, NY, nx, ny);
    POLYBENCH_2D_ARRAY_DECL(ey, DATA_TYPE, NX, NY, nx, ny);
    POLYBENCH_2D_ARRAY_DECL(hz, DATA_TYPE, NX, NY, nx, ny);
    POLYBENCH_1D_ARRAY_DECL(_fict_, DATA_TYPE, TMAX, tmax);

    /* Initialize array(s). */
    init_array(tmax, nx, ny, POLYBENCH_ARRAY(ex), POLYBENCH_ARRAY(ey), POLYBENCH_ARRAY(hz), POLYBENCH_ARRAY(_fict_));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_fdtd_2d(tmax, nx, ny, POLYBENCH_ARRAY(ex), POLYBENCH_ARRAY(ey), POLYBENCH_ARRAY(hz), POLYBENCH_ARRAY(_fict_));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination. */
    polybench_prevent_dce(print_array(nx, ny, POLYBENCH_ARRAY(ex), POLYBENCH_ARRAY(ey), POLYBENCH_ARRAY(hz)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(ex);
    POLYBENCH_FREE_ARRAY(ey);
    POLYBENCH_FREE_ARRAY(hz);
    POLYBENCH_FREE_ARRAY(_fict_);

    return 0;
}

```

</details>

<details><summary>floyd-warshall</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
/* Default data type is double, default size is 5000x5000. */
#include "floyd-warshall.h"

/* Array initialization. */
static
void init_array (int n, DATA_TYPE POLYBENCH_2D(path,N,N,n,n))
{
  int i, j;
  POLYBENCH_2D_FOOPRINT_BEGIN(path, N, N, n, n);
  for (i = 0; i < n; i++)
     for (j = 0; j < n; j++) {
        POLYBENCH_2D_REF(path, N, N, n, n) = (DATA_TYPE)(((i+1)*(j+1))/n/2);
     }
  POLYBENCH_2D_FOOPRINT_END(path, N, N, n, n);
}

/* DCE code. Must scan the entire live-out data
   (unchanged between dump_line and dump_end). Refresh
   only the elements of the arrays that are still live
   out at the end of the execution. */
static
void print_array(int n, DATA_TYPE POLYBENCH_2D(path,N,N,n,n))

{
   int i, j;
   POLYBENCH_2D_FOOPRINT_BEGIN(path, N, N, n, n);
   for (i = 0; i < n; i++)
      for (j = 0; j < n; j++) {
         if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
         fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, POLYBENCH_2D_REF(path, N, N, n, n));
      }
   POLYBENCH_2D_FOOPRINT_END(path, N, N, n, n);
}

//   void floyd_warshall(int n, int path[2000][2000])

void kernel_floyd_warshall(int n, DATA_TYPE POLYBENCH_2D(path, N, N, n, n))

{
#undef min
#define min(x,y) (((x)<(y))?(x):(y))
   int i, j, k;
#pragma scop
   for (k = 0; k < _PB_N; k++)
      for(i = 0; i < _PB_N; i++)
         for(j = 0; j < _PB_N; j++) {
            printf("before %5d %5d -> %5d\n",
                          path[i][k], path[k][j], path[i][j]);
            path[i][j] = min(path[i][j], path[i][k] + path[k][j]);
            printf("after  %5d %5d -> %5d\n",
                          path[i][k], path[k][j], path[i][j]);
         }
#pragma endscop
}


int main(int argc, char** argv)
{
/* Retrieve problem size. */
int n = N;

/* Variable declaration/allocation. */
POLYBENCH_2D_ARRAY_DECL(path, DATA_TYPE, N, N, n, n);
POLYBENCH_ALLOCATION(path, DATA_TYPE, N * N);

/* Initialize array(s). */
init_array (n, POLYBENCH_ARRAY(path));

/* Start timer. */
polybench_start_instruments;

/* Run kernel. */
kernel_floyd_warshall (n, POLYBENCH_ARRAY(path));

/* Stop and print timer. */
polybench_stop_instruments;
polybench_print_instruments;

/* Prevent dead-code elimination. All live-out data must be printed
   by the function call in argument. */
polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(path)));

/* Be clean. */
POLYBENCH_FREE_ARRAY(path);

return 0;
}
```

</details>
	
<details><summary>gemm</summary>

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
/* Include polybench common header. */
#include <polybench.h>
/* Include benchmark-specific header. */
/* Default to LARGE_DATASET. */
#include "gemm.h"
/* Array initialization. */
static
void init_array(int ni, int nj, int nk,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),
		DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj))
{
  int i, j;
  *alpha = 1.5;
  *beta = 1.2;
  POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, NI, NK, ni, nk);
  POLYBENCH_2D_ARRAY_DECL(B, DATA_TYPE, NK, NJ, nk, nj);
  POLYBENCH_2D_ARRAY_DECL(C, DATA_TYPE, NI, NJ, ni, nj);
  for (i = 0; i < ni; i++)
    for (j = 0; j < nk; j++)
      DATA_TYPE_MUL(POLYBENCH_ARRAY(A)[i][j], ((DATA_TYPE) i*j) / ni);
  for (i = 0; i < nk; i++)
    for (j = 0; j < nj; j++)
      DATA_TYPE_MUL(POLYBENCH_ARRAY(B)[i][j], ((DATA_TYPE) i*j + 1) / nj);
  for (i = 0; i < ni; i++)
    for (j = 0; j < nj; j++)
      DATA_TYPE_MUL(POLYBENCH_ARRAY(C)[i][j], ((DATA_TYPE) i*j + 2) / nj);
}
/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int ni, int nj,
		 DATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj))
{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("C");
  for (i = 0; i < ni; i++)
    for (j = 0; j < nj; j++) {
	if ((i * ni + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "
");
	fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, C[i][j]);
    }
  POLYBENCH_DUMP_END;
}
/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_gemm(int ni, int nj, int nk,
		 DATA_TYPE alpha,
		 DATA_TYPE beta,
		 DATA_TYPE POLYBENCH_2D(C,NI,NJ,ni,nj),
		 DATA_TYPE POLYBENCH_2D(A,NI,NK,ni,nk),
		 DATA_TYPE POLYBENCH_2D(B,NK,NJ,nk,nj))
{
  int i, j, k;
  POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, NI, NK, ni, nk);
  POLYBENCH_2D_ARRAY_DECL(B, DATA_TYPE, NK, NJ, nk, nj);
  POLYBENCH_2D_ARRAY_DECL(C, DATA_TYPE, NI, NJ, ni, nj);
#pragma scop
  for (i = 0; i < _PB_NI; i++)
    for (j = 0; j < _PB_NJ; j++)
      C[i][j] *= beta;
  for (i = 0; i < _PB_NI; i++) {
    for (j = 0; j < _PB_NJ; j++)
      for (k = 0; k < _PB_NK; k++)
        C[i][j] += alpha * A[i][k] * B[k][j];
  }
#pragma endscop
}
int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int ni = NI;
  int nj = NJ;
  int nk = NK;
  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(C, DATA_TYPE, NI, NJ, ni, nj);
  POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, NI, NK, ni, nk);
  POLYBENCH_2D_ARRAY_DECL(B, DATA_TYPE, NK, NJ, nk, nj);
  /* Initialize array(s). */
  init_array (ni, nj, nk, &alpha, &beta, POLYBENCH_ARRAY(C), POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));
  /* Start timer. */
  polybench_start_instruments;
  /* Run kernel. */
  kernel_gemm (ni, nj, nk, alpha, beta, POLYBENCH_ARRAY(C),POLYBENCH_ARRAY(A),POLYBENCH_ARRAY(B));
  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;
  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(ni, nj, POLYBENCH_ARRAY(C)));
  /* Be clean. */
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
  return 0;
}
```

</details>

<details><summary>gemver</summary>

```c
/** 
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* gemver.c: this file is part of PolyBench/C */
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "gemver.h"

/* Array initialization. */
static void init_array(
    int n,
    DATA_TYPE *alpha,
    DATA_TYPE *beta,
    DATA_TYPE POLYBENCH_2D(A, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(u1, N, n),
    DATA_TYPE POLYBENCH_1D(v1, N, n),
    DATA_TYPE POLYBENCH_1D(u2, N, n),
    DATA_TYPE POLYBENCH_1D(v2, N, n),
    DATA_TYPE POLYBENCH_1D(w, N, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(y, N, n),
    DATA_TYPE POLYBENCH_1D(z, N, n))
{
    int i, j;

    *alpha = 1.5;
    *beta = 1.2;
    DATA_TYPE fn = (DATA_TYPE)n;

    for (i = 0; i < n; i++) {
        u1[i] = i;
        u2[i] = ((i + 1) / fn) / 2.0;
        v1[i] = ((i + 1) / fn) / 4.0;
        v2[i] = ((i + 1) / fn) / 6.0;
        y[i] = ((i + 1) / fn) / 8.0;
        z[i] = ((i + 1) / fn) / 9.0;
        x[i] = 0.0;
        w[i] = 0.0;
    }

    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            A[i][j] = (DATA_TYPE)(i * j % n) / n;
        }
    }
}

/* Print array for verification. */
static void print_array(int n, DATA_TYPE POLYBENCH_1D(w, N, n)) {
    int i;
    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("w");

    for (i = 0; i < n; i++) {
        if (i % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
        fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, w[i]);
    }

    POLYBENCH_DUMP_END("w");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. */
static void kernel_gemver(
    int n,
    DATA_TYPE alpha,
    DATA_TYPE beta,
    DATA_TYPE POLYBENCH_2D(A, N, N, n, n),
    DATA_TYPE POLYBENCH_1D(u1, N, n),
    DATA_TYPE POLYBENCH_1D(v1, N, n),
    DATA_TYPE POLYBENCH_1D(u2, N, n),
    DATA_TYPE POLYBENCH_1D(v2, N, n),
    DATA_TYPE POLYBENCH_1D(w, N, n),
    DATA_TYPE POLYBENCH_1D(x, N, n),
    DATA_TYPE POLYBENCH_1D(y, N, n),
    DATA_TYPE POLYBENCH_1D(z, N, n))
{
    int i, j;

#pragma scop
    /* AXPY */
    for (i = 0; i < _PB_N; i++) {
        for (j = 0; j < _PB_N; j++) {
            A[i][j] += u1[i] * v1[j] + u2[i] * v2[j];
        }
    }

    /* DOT */
    for (i = 0; i < _PB_N; i++) {
        for (j = 0; j < _PB_N; j++) {
            x[i] += beta * A[j][i] * y[j];
        }
    }

    /* AXPY */
    for (i = 0; i < _PB_N; i++) {
        x[i] += z[i];
    }

    /* GEMV */
    for (i = 0; i < _PB_N; i++) {
        for (j = 0; j < _PB_N; j++) {
            w[i] += alpha * A[i][j] * x[j];
        }
    }
#pragma endscop
}

int main(int argc, char **argv) {
    /* Retrieve problem size. */
    int n = N;

    /* Variable declaration/allocation. */
    DATA_TYPE alpha;
    DATA_TYPE beta;
    POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, N, N, n, n);
    POLYBENCH_1D_ARRAY_DECL(u1, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(v1, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(u2, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(v2, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(w, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(x, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(y, DATA_TYPE, N, n);
    POLYBENCH_1D_ARRAY_DECL(z, DATA_TYPE, N, n);

    /* Initialize arrays. */
    init_array(n, &alpha, &beta, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(u1),
               POLYBENCH_ARRAY(v1), POLYBENCH_ARRAY(u2), POLYBENCH_ARRAY(v2),
               POLYBENCH_ARRAY(w), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(y),
               POLYBENCH_ARRAY(z));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_gemver(n, alpha, beta, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(u1),
                  POLYBENCH_ARRAY(v1), POLYBENCH_ARRAY(u2), POLYBENCH_ARRAY(v2),
                  POLYBENCH_ARRAY(w), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(y),
                  POLYBENCH_ARRAY(z));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination. */
    polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(w)));

    /* Free memory. */
    POLYBENCH_FREE_ARRAY(A);
    POLYBENCH_FREE_ARRAY(u1);
    POLYBENCH_FREE_ARRAY(v1);
    POLYBENCH_FREE_ARRAY(u2);
    POLYBENCH_FREE_ARRAY(v2);
    POLYBENCH_FREE_ARRAY(w);
    POLYBENCH_FREE_ARRAY(x);
    POLYBENCH_FREE_ARRAY(y);
    POLYBENCH_FREE_ARRAY(z);

    return 0;
}
```

</details>

<details><summary>gesummv</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
/* Default data type is double, default size is 1000. */
#include "gesummv.h"

/* Array initialization. */
static
void init_array(int n,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		DATA_TYPE POLYBENCH_2D(B,N,N,n,n),
		DATA_TYPE POLYBENCH_1D(x,N,n))
{
  int i, j;

  *alpha = 1.5;
  *beta = 1.2;

  for (i = 0; i < n; i++) {
    x[i] = (DATA_TYPE)(i % n) / n;
    for (j = 0; j < n; j++) {
      A[i][j] = (DATA_TYPE) ((i*j+1) % n) / n;
      B[i][j] = (DATA_TYPE) ((i*j+2) % n) / n;
    }
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_1D(y,N,n))
{
  int i;

  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("y");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, y[i]);
  }
  POLYBENCH_DUMP_END("y");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_gesummv(int n, DATA_TYPE alpha, DATA_TYPE beta,
		    DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		    DATA_TYPE POLYBENCH_2D(B,N,N,n,n),
		    DATA_TYPE POLYBENCH_1D(tmp,N,n),
		    DATA_TYPE POLYBENCH_1D(x,N,n),
		    DATA_TYPE POLYBENCH_1D(y,N,n))
{
  int i, j;

#pragma scop
  for (i = 0; i < _PB_N; i++)
    {
      tmp[i] = SCALAR_VAL(0.0);
      y[i] = SCALAR_VAL(0.0);
      for (j = 0; j < _PB_N; j++)
	{
	  tmp[i] = A[i][j] * x[j] + tmp[i];
	  y[i] = B[i][j] * x[j] + y[i];
	}
      y[i] = alpha * tmp[i] + beta * y[i];
    }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,N,n,n);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,N,n,n);
  POLYBENCH_1D_ARRAY_DECL(tmp,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(x,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(y,DATA_TYPE,N,n);

  /* Initialize array(s). */
  init_array (n, &alpha, &beta, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B), POLYBENCH_ARRAY(x));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_gesummv (n, alpha, beta,
		  POLYBENCH_ARRAY(A),
		  POLYBENCH_ARRAY(B),
		  POLYBENCH_ARRAY(tmp),
		  POLYBENCH_ARRAY(x),
		  POLYBENCH_ARRAY(y));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(y)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
  POLYBENCH_FREE_ARRAY(tmp);
  POLYBENCH_FREE_ARRAY(x);
  POLYBENCH_FREE_ARRAY(y);

  return 0;
}
```

</details>

<details><summary>gramschmidt</summary>

```c
/**
 * This version is stamped on May 10, 2016
 * 
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 * 
 * Web address: http://polybench.sourceforge.net
 */

/* gramschmidt.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "gramschmidt.h"

/* Array initialization. */
static void init_array(int m, int n,
                       DATA_TYPE POLYBENCH_2D(A, M, N, m, n),
                       DATA_TYPE POLYBENCH_2D(R, N, N, n, n),
                       DATA_TYPE POLYBENCH_2D(Q, M, N, m, n)) {
    int i, j;

    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++) {
            A[i][j] = ((((DATA_TYPE)((i * j) % m)) / m) * 100) + 10;
            Q[i][j] = 0.0;
        }

    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            R[i][j] = 0.0;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int m, int n,
                        DATA_TYPE POLYBENCH_2D(A, M, N, m, n)) {
    int i, j;

    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("A");

    for (i = 0; i < m; i++)
        for (j = 0; j < n; j++) {
            if ((i * n + j) % 20 == 0)
                fprintf(POLYBENCH_DUMP_TARGET, "\n");
            fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
        }

    POLYBENCH_DUMP_END("A");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_gramschmidt(int m, int n,
                               DATA_TYPE POLYBENCH_2D(A, M, N, m, n),
                               DATA_TYPE POLYBENCH_2D(R, N, N, n, n),
                               DATA_TYPE POLYBENCH_2D(Q, M, N, m, n)) {
    int i, j, k;
    DATA_TYPE nrm;

#pragma scop
    for (k = 0; k < _PB_N; k++) {
        nrm = SCALAR_VAL(0.0);
        for (i = 0; i < _PB_M; i++)
            nrm += A[i][k] * A[i][k];
        R[k][k] = SQRT_FUN(nrm);
        for (i = 0; i < _PB_M; i++)
            Q[i][k] = A[i][k] / R[k][k];
        for (j = k + 1; j < _PB_N; j++) {
            R[k][j] = SCALAR_VAL(0.0);
            for (i = 0; i < _PB_M; i++)
                R[k][j] += Q[i][k] * A[i][j];
            for (i = 0; i < _PB_M; i++)
                A[i][j] = A[i][j] - Q[i][k] * R[k][j];
        }
    }
#pragma endscop
}

int main(int argc, char **argv) {
    /* Retrieve problem size. */
    int m = M;
    int n = N;

    /* Variable declaration/allocation. */
    POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, M, N, m, n);
    POLYBENCH_2D_ARRAY_DECL(R, DATA_TYPE, N, N, n, n);
    POLYBENCH_2D_ARRAY_DECL(Q, DATA_TYPE, M, N, m, n);

    /* Initialize array(s). */
    init_array(m, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(R), POLYBENCH_ARRAY(Q));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_gramschmidt(m, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(R), POLYBENCH_ARRAY(Q));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination. All live-out data must be printed
       by the function call in argument. */
    polybench_prevent_dce(print_array(m, n, POLYBENCH_ARRAY(A)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(A);
    POLYBENCH_FREE_ARRAY(R);
    POLYBENCH_FREE_ARRAY(Q);

    return 0;
}

```

</details>

<details><summary>heat-3d</summary>

```c
/**
 * This version is stamped on May 10, 2016
 *
 * Contact:
 *   Louis-Noel Pouchet <pouchet.ohio-state.edu>
 *   Tomofumi Yuki <tomofumi.yuki.fr>
 *
 * Web address: http://polybench.sourceforge.net
 */

/* heat-3d.c: this file is part of PolyBench/C */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "heat-3d.h"

/* Array initialization. */
static void init_array(int n,
                       DATA_TYPE POLYBENCH_3D(A, N, N, N, n, n, n),
                       DATA_TYPE POLYBENCH_3D(B, N, N, N, n, n, n)) {
    int i, j, k;
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            for (k = 0; k < n; k++) {
                A[i][j][k] = (SCALAR_VAL(0.125) + (i + j + (n - k)) * (SCALAR_VAL(0.125)) / n);
                B[i][j][k] = (SCALAR_VAL(0.125) + (i + j + (n - k)) * (SCALAR_VAL(0.125)) / n);
            }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static void print_array(int n,
                        DATA_TYPE POLYBENCH_3D(A, N, N, N, n, n, n)) {
    int i, j, k;
    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("A");
    for (i = 0; i < n; i++)
        for (j = 0; j < n; j++)
            for (k = 0; k < n; k++) {
                if ((i * n * n + j * n + k) % 20 == 0)
                    fprintf(POLYBENCH_DUMP_TARGET, "\n");
                fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j][k]);
            }
    POLYBENCH_DUMP_END("A");
    POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static void kernel_heat_3d(int tsteps, int n,
                           DATA_TYPE POLYBENCH_3D(A, N, N, N, n, n, n),
                           DATA_TYPE POLYBENCH_3D(B, N, N, N, n, n, n)) {
#pragma scop
    for (int t = 1; t <= _PB_TSTEPS; t++) {
        for (int i = 1; i < _PB_N - 1; i++) {
            for (int j = 1; j < _PB_N - 1; j++) {
                for (int k = 1; k < _PB_N - 1; k++) {
                    B[i][j][k] = SCALAR_VAL(0.125) * (A[i + 1][j][k] - SCALAR_VAL(2.0) * A[i][j][k] + A[i - 1][j][k])
                               + SCALAR_VAL(0.125) * (A[i][j + 1][k] - SCALAR_VAL(2.0) * A[i][j][k] + A[i][j - 1][k])
                               + SCALAR_VAL(0.125) * (A[i][j][k + 1] - SCALAR_VAL(2.0) * A[i][j][k] + A[i][j][k - 1])
                               + A[i][j][k];
                }
            }
        }
        for (int i = 1; i < _PB_N - 1; i++) {
            for (int j = 1; j < _PB_N - 1; j++) {
                for (int k = 1; k < _PB_N - 1; k++) {
                    A[i][j][k] = SCALAR_VAL(0.125) * (B[i + 1][j][k] - SCALAR_VAL(2.0) * B[i][j][k] + B[i - 1][j][k])
                               + SCALAR_VAL(0.125) * (B[i][j + 1][k] - SCALAR_VAL(2.0) * B[i][j][k] + B[i][j - 1][k])
                               + SCALAR_VAL(0.125) * (B[i][j][k + 1] - SCALAR_VAL(2.0) * B[i][j][k] + B[i][j][k - 1])
                               + B[i][j][k];
                }
            }
        }
    }
#pragma endscop
}

int main(int argc, char** argv) {
    /* Retrieve problem size. */
    int n = N;
    int tsteps = TSTEPS;

    /* Variable declaration/allocation. */
    POLYBENCH_3D_ARRAY_DECL(A, DATA_TYPE, N, N, N, n, n, n);
    POLYBENCH_3D_ARRAY_DECL(B, DATA_TYPE, N, N, N, n, n, n);

    /* Initialize array(s). */
    init_array(n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

    /* Start timer. */
    polybench_start_instruments;

    /* Run kernel. */
    kernel_heat_3d(tsteps, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

    /* Stop and print timer. */
    polybench_stop_instruments;
    polybench_print_instruments;

    /* Prevent dead-code elimination. All live-out data must be printed
       by the function call in argument. */
    polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

    /* Be clean. */
    POLYBENCH_FREE_ARRAY(A);
    POLYBENCH_FREE_ARRAY(B);

    return 0;
}

```

</details>

<details><summary>jacobi-1d</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "jacobi-1d.h"

/* Array initialization. */
static
void init_array (int n,
		 DATA_TYPE POLYBENCH_1D(A,N,n),
		 DATA_TYPE POLYBENCH_1D(B,N,n))
{
  int i;

  for (i = 0; i < n; i++) {
      A[i] = ((DATA_TYPE) i+ 2) / n;
      B[i] = ((DATA_TYPE) i+ 3) / n;
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_1D(A,N,n))

{
  int i;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("A");
  for (i = 0; i < n; i++) {
    if (i%20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i]);
  }
  POLYBENCH_DUMP_END("A");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_jacobi_1d(int tsteps,
		      int n,
		      DATA_TYPE POLYBENCH_1D(A,N,n),
		      DATA_TYPE POLYBENCH_1D(B,N,n))

{
  int t, i;

#pragma scop
  for (t = 0; t < _PB_TSTEPS; t++) {
    for (i = 1; i < _PB_N - 1; i++) {
	B[i] = SCALAR_VAL(0.333) * (A[i-1] + A[i] + A[i + 1]);
    }
    for (i = 1; i < _PB_N - 1; i++) {
	A[i] = SCALAR_VAL(0.333) * (B[i-1] + B[i] + B[i + 1]);
    }
  }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int tsteps = TSTEPS;

  /* Variable declaration/allocation. */
  POLYBENCH_1D_ARRAY_DECL(A,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(B,DATA_TYPE,N,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_jacobi_1d (tsteps, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);

  return 0;
}
```

</details>

<details><summary>jacobi-2d</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "jacobi-2d.h"

/* Array initialization. */
static
void init_array (int n,
		 DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		 DATA_TYPE POLYBENCH_2D(B,N,N,n,n))
{
  int i, j;

  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      A[i][j] = ((DATA_TYPE) ((i+1)*(j+1))) / n;
      B[i][j] = ((DATA_TYPE) ((i+2)*(j+2))) / n;
    }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_2D(A,N,N,n,n))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("A");
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      if ((i*n+j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
    }
  POLYBENCH_DUMP_END("A");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_jacobi_2d(int tsteps,
		      int n,
		      DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		      DATA_TYPE POLYBENCH_2D(B,N,N,n,n))

{
  int t, i, j;

#pragma scop
  for (t = 0; t < _PB_TSTEPS; t++) {
    for (i = 1; i < _PB_N - 1; i++) {
      for (j = 1; j < _PB_N - 1; j++) {
	B[i][j] = SCALAR_VAL(0.2) * (A[i][j] + A[i][j-1] + A[i][1+j] + A[1+i][j] + A[i-1][j]);
      }
    }
    for (i = 1; i < _PB_N - 1; i++) {
      for (j = 1; j < _PB_N - 1; j++) {
	A[i][j] = SCALAR_VAL(0.2) * (B[i][j] + B[i][j-1] + B[i][1+j] + B[1+i][j] + B[i-1][j]);
      }
    }
  }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int tsteps = TSTEPS;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,N,n,n);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,N,n,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_jacobi_2d (tsteps, n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
  
  return 0;
}
```

</details>

<details><summary>lu</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "lu.h"

/* Array initialization. */
static
void init_array(int n,
		DATA_TYPE POLYBENCH_2D(A,N,N,n,n))
{
  int i, j;
	
  for (i = 0; i < n; i++)
    for (j = 0; j <= i; j++)
      A[i][j] = (DATA_TYPE)((-j % n) / n) + 1;
	
  /* Make the matrix positive semi-definite. */
  /* not necessary for LU, but using same code as cholesky */
  int r,s,t;
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,N,n,n);

  for (r = 0; r < n; ++r)
    for (s = 0; s < n; ++s) {
      B[r][s] = 0;
      for (t = 0; t < n; ++t)
	B[r][s] += A[r][t] * A[s][t];
    }
  
  for (r = 0; r < n; ++r)
     for (s = 0; s < n; ++s)
        A[r][s] = B[r][s];
		
  POLYBENCH_FREE_ARRAY(B);
	
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_2D(A,N,N,n,n))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("A");
  for (i = 0; i < n; i++) 
    for (j = 0; j < n; j++) {
    if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
    fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
    }
  POLYBENCH_DUMP_END("A");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_lu(int n,
	       DATA_TYPE POLYBENCH_2D(A,N,N,n,n))
{
  int i, j, k;

#pragma scop
  for (i = 0; i < _PB_N; i++)
    for (j = 0; j <i; j++) {
       A[i][j] /= A[j][j];
	for (k = j+1; k < _PB_N; k++)
	  A[i][k] -= A[i][j] * A[j][k];
    }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,N,n,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(A));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_lu (n, POLYBENCH_ARRAY(A));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);

  return 0;
}
```

</details>

<details><summary>ludcmp</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "ludcmp.h"

/* Array initialization. */
static
void init_array(int n,
		DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		DATA_TYPE POLYBENCH_1D(b,N,n),
		DATA_TYPE POLYBENCH_1D(x,N,n),
		DATA_TYPE POLYBENCH_1D(y,N,n))
{
  int i, j;
	
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,N,n,n);

  DATA_TYPE fn;
  fn= (DATA_TYPE)n;

  for (i = 0; i < n; i++) {
      x[i] = 0;
      y[i] = 0;
      b[i] = (i+1)/fn/2.0 + 4;//Leading row elements sum to 1.0/2.0
  }

  for (i = 0; i < n; i++)
    for (j = 0; j <= i; j++)
	A[i][j] = (DATA_TYPE) -j % n / n + 1;
  	
  /* Make the matrix positive semi-definite. */
  /* not necessary for LU, but using same code as cholesky */
  int r,s,t;
  for (r = 0; r < n; ++r)
    for (s = 0; s < n; ++s) {
      B[r][s] = 0;
      for (t = 0; t < n; ++t)
	B[r][s] += A[r][t] * A[s][t];
    }
  
  for (r = 0; r < n; ++r)
     for (s = 0; s < n; ++s)
        A[r][s] = B[r][s];
		
  POLYBENCH_FREE_ARRAY(B);
	
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		 DATA_TYPE POLYBENCH_1D(b,N,n))

{
  int i, j;

  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("A");
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
	if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
	fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
    }
  }
  POLYBENCH_DUMP_END("A");
  POLYBENCH_DUMP_BEGIN("b");
  for (i = 0; i < n; i++) {
    if (i%20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, b[i]);
  }
  POLYBENCH_DUMP_END("b");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_ludcmp(int n,
		   DATA_TYPE POLYBENCH_2D(A,N,N,n,n),
		   DATA_TYPE POLYBENCH_1D(b,N,n),
		   DATA_TYPE POLYBENCH_1D(x,N,n),
		   DATA_TYPE POLYBENCH_1D(y,N,n))
{
  int i, j, k;

  DATA_TYPE w;

#pragma scop
  for (i = 0; i < _PB_N; i++) {
    for (j = 0; j <i; j++) {
       w = A[i][j];
	for (k = 0; k < j; k++) {
	   w  = w- A[i][k] * A[k][j];
	}
        A[i][j] = w / A[j][j];
    }
   for (j = i; j < _PB_N; j++) {
    w = A[i][j];
      for (k = 0; k < i; k++) {
         w = w - A[i][k] * A[k][j];
       }
       A[i][j] = w;
     }
  }

  for (i = 0; i < _PB_N; i++) {
    w = b[i];
    for (j = 0; j < i; j++)
       w -= A[i][j] * y[j];
    y[i] = w;
  }

  for (i = _PB_N-1; i >=0; i--) {
     w = y[i];
     for (j = i+1; j < _PB_N; j++)
        w -= A[i][j] * x[j];
     x[i] = w / A[i][i];
  }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,N,n,n);
  POLYBENCH_1D_ARRAY_DECL(b,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(x,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(y,DATA_TYPE,N,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(b), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(y));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_ludcmp (n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(b), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(y));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(b)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(b);
  POLYBENCH_FREE_ARRAY(x);
  POLYBENCH_FREE_ARRAY(y);

  return 0;
}

```

</details>

<details><summary>nussinov</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

#include <polybench.h>
#include "nussinov.h"

static
void init_array (int n, DATA_TYPE POLYBENCH_2D(seq,N,N,n,n), DATA_TYPE POLYBENCH_2D(table,N,N,n,n))

{
  int i, j;

  for (i=0; i<_PB_N; i++) {
    for (j=0; j<_PB_N; j++) {
      	 table[i][j]=0;
    }
    seq[i][i] = 0;
   }
   for (i=0; i<_PB_N; i++) {
      seq[i][0]=1;
      seq[0][i]=1;
   }
}


static
void print_array(int n, DATA_TYPE POLYBENCH_2D(table,N,N,n,n))

{
    int i, j;
    POLYBENCH_DUMP_START;
    POLYBENCH_DUMP_BEGIN("table");
    for (i=0; i<n; i++) {
       for (j=i; j<n; j++) {
           if ((i*n+j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
           fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, table[i][j]);
       }
    }
    POLYBENCH_DUMP_END("table");
    POLYBENCH_DUMP_FINISH;
}


void kernel_nussinov(int n, DATA_TYPE POLYBENCH_2D(table,N,N,n,n), DATA_TYPE POLYBENCH_2D(seq,N,N,n,n))
{
	int i, j, k;
	for (i=0; i<_PB_N; i++)
	{
		for (j=0; j<_PB_N; j++)
	 	{
			for (k=0; k<_PB_N; k++)
	 		{
				if (j-1>=0)
				{
					table[j][k]=max_score(table[j][k], table[j-1][k]);          
				}
				if (k+1<_PB_N)
				{
					table[j][k]=max_score(table[j][k], table[j][k+1]);
				} 
				   if (j-1>=0 && k+1<_PB_N)
				{
			 		 if ((j-1)<(k+1))
			 		 {
					    table[j][k]=max_score(table[j][k], (table[j-1][k+1]+ seq[j][k]));
			 		 }
				}
				for (i1=j-1; i1>=0; i1--)
				{
					for (i2=i1; i2<k+1; i2++)
					{
					    if (i1<i2)
					    {
						table[j][k]=max_score(table[j][k], table[i1][i2]+table[i2+1][j]);
					    }
					}
				}
	   		}	
	 	}
	}
}


int main(int argc, char** argv)
{
  int n = N;

  POLYBENCH_2D_ARRAY_DECL(table, DATA_TYPE, N, N, n, n);
  POLYBENCH_2D_ARRAY_DECL(seq, DATA_TYPE, N, N, n, n);

  init_array(n, POLYBENCH_ARRAY(seq), POLYBENCH_ARRAY(table));

  polybench_start_instruments;
  kernel_nussinov(n, POLYBENCH_ARRAY(table), POLYBENCH_ARRAY(seq));
  polybench_stop_instruments;
  polybench_print_instruments;

  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(table)));
  POLYBENCH_FREE_ARRAY(seq);
  POLYBENCH_FREE_ARRAY(table);

  return 0;
}
```

</details>

<details><summary>seidel-2d</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "seidel-2d.h"


/* Array initialization. */
static
void init_array (int n, DATA_TYPE POLYBENCH_2D(A,N,n,n))
{
  int i, j;

  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++)
      A[i][j] = (DATA_TYPE) (i*(j+2) + 2) / n;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n, DATA_TYPE POLYBENCH_2D(A,N,n,n))
{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("A");
  for (i = 0; i < n; i++) 
    for (j = 0; j < n; j++) {
      if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, A[i][j]);
    }
  POLYBENCH_DUMP_END("A");
  POLYBENCH_DUMP_FINISH;
}

/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_seidel_2d(int tsteps, int n, DATA_TYPE POLYBENCH_2D(A, N, n, n)) {
  int t, i, j;
#pragma scop
  for (t=0; t<=_PB_TSTEPS-1; t++)
     for (i=1; i<=_PB_N-2; i++)
        for (j=1; j<=_PB_N-2; j++)
           A[i][j] = (A[(i-1)][(j-1)] + A[(i-1)][j] + A[(i-1)][(j+1)]
                      + A[i][(j-1)] + A[i][j] + A[i][(j+1)]
                      + A[(i+1)][(j-1)] + A[(i+1)][j] + A[(i+1)][(j+1)])/SCALAR_VAL(9.0);
#pragma endscop
}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int tsteps = TSTEPS;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,N,n,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(A));

  /* Start timer. */
  polybench_start_instruments;


  /* Run kernel. */
  kernel_seidel_2d (tsteps, n, POLYBENCH_ARRAY(A));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(A)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);

  return 0;
}
```

</details>

<details><summary>symm</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "symm.h"


/* Array initialization. */
static
void init_array(int m, int n,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(C,N,M,n,m),
		DATA_TYPE POLYBENCH_2D(A,M,M,m,m),
		DATA_TYPE POLYBENCH_2D(B,N,M,n,m))
{
  int i, j;

  *alpha = 1.5;
  *beta = 1.2;
  for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
	C[i][j] = (DATA_TYPE) ((i+j) % 100) / m;
	B[i][j] = (DATA_TYPE) ((n+i-j) % 100) / m;
    }
    for (j = 0; j < m; j++) {
	A[i][j] = (DATA_TYPE) ((i+j) % 100)/m;
    }
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. Note that this
   function is called only if the -DPOLYBENCH_DUMP_ARRAYS is given to
   the compiler. Hence, the code must be guarded by manually checking
   POLYBENCH_DUMP_ARRAYS. */
static
void print_array(int m, int n,
		 DATA_TYPE POLYBENCH_2D(C,N,M,n,m))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("C");
  for (i = 0; i < m; i++) 
    for (j = 0; j < n; j++) {
      if ((i * m + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, C[i][j]);
    }
  POLYBENCH_DUMP_END("C");
  POLYBENCH_DUMP_FINISH;
}



/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_symm(int m, int n,
		 DATA_TYPE alpha,
		 DATA_TYPE beta,
		 DATA_TYPE POLYBENCH_2D(C,N,M,n,m),
		 DATA_TYPE POLYBENCH_2D(A,M,M,m,m),
		 DATA_TYPE POLYBENCH_2D(B,N,M,n,m))
{
  int i, j, k;
  DATA_TYPE temp2;

#pragma scop
  for (i = 0; i < _PB_M; i++)
    for (j = 0; j < _PB_N; j++)
      {
      temp2 = 0;
      for (k = 0; k < i; k++) {
	  C[k][j] += alpha*B[i][j] * A[i][k];
	  temp2 += B[k][j] * A[i][k];
      }
      C[i][j] = beta * C[i][j] + alpha*B[i][j] * A[i][i] + alpha * temp2;
     }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int m = M;
  int n = N;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(C,DATA_TYPE,N,M,n,m);
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,M,M,m,m);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,M,n,m);

  /* Initialize array(s). */
  init_array (m, n, &alpha, &beta,
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_symm (m, n,
	       alpha, beta,
	       POLYBENCH_ARRAY(C),
	       POLYBENCH_ARRAY(A),
	       POLYBENCH_ARRAY(B));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(m, n, POLYBENCH_ARRAY(C)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);

  return 0;
}

```

</details>

<details><summary>syr2k</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "syr2k.h"


/* Array initialization. */
static
void init_array(int n, int m,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(C,N,N,n,n),
		DATA_TYPE POLYBENCH_2D(A,N,M,n,m),
		DATA_TYPE POLYBENCH_2D(B,N,M,n,m))
{
  int i, j;

  *alpha = 1.5;
  *beta = 1.2;
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++) {
      A[i][j] = ((DATA_TYPE) i*j) / N;
      B[i][j] = ((DATA_TYPE) i*j) / N;
  }
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++) {
      C[i][j] = ((DATA_TYPE) i*j) / N;
  }
  
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. Note that this
   function is called only if the -DPOLYBENCH_DUMP_ARRAYS is given to
   the compiler. Hence, the code must be guarded by manually checking
   POLYBENCH_DUMP_ARRAYS. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_2D(C,N,N,n,n))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("C");
  for (i = 0; i < n; i++) 
    for (j = 0; j < n; j++) {
      if ((i * m + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, C[i][j]);
    }
  POLYBENCH_DUMP_END("C");
  POLYBENCH_DUMP_FINISH;
}



/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_syr2k(int n, int m,
		  DATA_TYPE alpha,
		  DATA_TYPE beta,
		  DATA_TYPE POLYBENCH_2D(C,N,N,n,n),
		  DATA_TYPE POLYBENCH_2D(A,N,M,n,m),
		  DATA_TYPE POLYBENCH_2D(B,N,M,n,m))
{
  int i, j, k;

#pragma scop
  for (i = 0; i < _PB_N; i++)
    for (j = 0; j <= i; j++){
        C[i][j] *= beta;

      for (k = 0; k < _PB_M; k++) {
	C[i][j] += alpha * A[j][k] * B[i][k] + alpha * B[j][k] * A[i][k];
      }
    }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int m = M;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(C,DATA_TYPE,N,N,n,n);
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,M,n,m);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,N,M,n,m);

  /* Initialize array(s). */
  init_array (n, m, &alpha, &beta,
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(A),
	      POLYBENCH_ARRAY(B));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_syr2k (n, m,
		alpha, beta,
		POLYBENCH_ARRAY(C),
		POLYBENCH_ARRAY(A),
		POLYBENCH_ARRAY(B));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(C)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);
 
  return 0;
}

```

</details>

<details><summary>syrk</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "syrk.h"


/* Array initialization. */
static
void init_array(int n, int m,
		DATA_TYPE *alpha,
		DATA_TYPE *beta,
		DATA_TYPE POLYBENCH_2D(C,N,N,n,n),
		DATA_TYPE POLYBENCH_2D(A,N,M,n,m))
{
  int i, j;

  *alpha = 1.5;
  *beta = 1.2;
  for (i = 0; i < n; i++)
    for (j = 0; j < m; j++)
      A[i][j] = ((DATA_TYPE) i*j) / n;
    
  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++)
      C[i][j] = ((DATA_TYPE) i*j) / n;
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. Note that this
   function is called only if the -DPOLYBENCH_DUMP_ARRAYS is given to
   the compiler. Hence, the code must be guarded by manually checking
   POLYBENCH_DUMP_ARRAYS. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_2D(C,N,N,n,n))

{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("C");
  for (i = 0; i < n; i++) 
    for (j = 0; j < n; j++) {
      if ((i * m + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, C[i][j]);
    }
  POLYBENCH_DUMP_END("C");
  POLYBENCH_DUMP_FINISH;
}



/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_syrk(int n, int m,
		 DATA_TYPE alpha,
		 DATA_TYPE beta,
		 DATA_TYPE POLYBENCH_2D(C,N,N,n,n),
		 DATA_TYPE POLYBENCH_2D(A,N,M,n,m))
{
  int i, j, k;

#pragma scop
  for (i = 0; i < _PB_N; i++) {
    for (j = 0; j <= i; j++)
	C[i][j] *= beta;
    for (k = 0; k < _PB_M; k++) {
      for (j = 0; j <= i; j++)
	C[i][j] += alpha * A[j][k] * A[i][k];
    }
  }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;
  int m = M;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  DATA_TYPE beta;
  POLYBENCH_2D_ARRAY_DECL(C,DATA_TYPE,N,N,n,n);
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,N,M,n,m);

  /* Initialize array(s). */
  init_array (n, m, &alpha, &beta,
	      POLYBENCH_ARRAY(C),
	      POLYBENCH_ARRAY(A));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_syrk (n, m,
	       alpha, beta,
	       POLYBENCH_ARRAY(C),
	       POLYBENCH_ARRAY(A));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(C)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(C);
  POLYBENCH_FREE_ARRAY(A);
 
  return 0;
}

```

</details>

<details><summary>trisolv</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "trisolv.h"

/* Array initialization. */
static
void init_array (int n,
		 DATA_TYPE POLYBENCH_2D(L,N,N,n,n),
		 DATA_TYPE POLYBENCH_1D(x,N,n),
		 DATA_TYPE POLYBENCH_1D(b,N,n))
{
  int i, j;

  for (i = 0; i < n; i++) {
      x[i] = -999;
      b[i] = (DATA_TYPE)(i+1)/n/2.0 + 4;
      for (j = 0; j <= i; j++)
	L[i][j] = (DATA_TYPE)(i+1)*(j+1)/n/3.0;
  }
}

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_1D(x,N,n))

{
  int i;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("x");
  for (i = 0; i < n; i++) {
    if (i%20 == 0) fprintf(POLYBENCH_DUMP_TARGET, "\n");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, x[i]);
  }
  POLYBENCH_DUMP_END("x");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */

void kernel_trisolv(int n,
		    DATA_TYPE POLYBENCH_2D(L,N,N,n,n),
		    DATA_TYPE POLYBENCH_1D(x,N,n),
		    DATA_TYPE POLYBENCH_1D(b,N,n))
{
  int i, j;

#pragma scop
  for (i = 0; i < _PB_N; i++) {
     x[i] = b[i];
     for (j = 0; j <i; j++)
        x[i] -= L[i][j] * x[j];
      x[i] = x[i] / L[i][i];
    }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int n = N;

  /* Variable declaration/allocation. */
  POLYBENCH_2D_ARRAY_DECL(L,DATA_TYPE,N,N,n,n);
  POLYBENCH_1D_ARRAY_DECL(x,DATA_TYPE,N,n);
  POLYBENCH_1D_ARRAY_DECL(b,DATA_TYPE,N,n);

  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_trisolv (n, POLYBENCH_ARRAY(L), POLYBENCH_ARRAY(x), POLYBENCH_ARRAY(b));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(x)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(L);
  POLYBENCH_FREE_ARRAY(x);
  POLYBENCH_FREE_ARRAY(b);

  return 0;
}

```
</details>

<details><summary>trmm</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>

/* Include polybench common header. */
#include <polybench.h>

/* Include benchmark-specific header. */
#include "trmm.h"

/* Array initialization. */
static
void init_array(int m, int n,
		DATA_TYPE *alpha,
		DATA_TYPE POLYBENCH_2D(A,M,M,m,m),
		DATA_TYPE POLYBENCH_2D(B,M,N,m,n))
{
  int i, j;
	
  *alpha = 1.5;
  for (i = 0; i < m; i++) {
    for (j = 0; j < n; j++) {
	B[i][j] = (DATA_TYPE) ((i+j) % 100) / m;
    }
    for (j = 0; j < m; j++) {
	A[i][j] = (DATA_TYPE) ((n+i-j) % 100) / m;
   }
  }
}	

/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output.
   Can be used also to check the correctness of the output. */
static
void print_array(int m, int n,
		 DATA_TYPE POLYBENCH_2D(B,M,N,m,n))
{
  int i, j;
  POLYBENCH_DUMP_START;
  POLYBENCH_DUMP_BEGIN("B");
  for (i = 0; i < m; i++) 
    for (j = 0; j < n; j++) {
      if ((i * n + j) % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "\n");
      fprintf (POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, B[i][j]);
    }
  POLYBENCH_DUMP_END("B");
  POLYBENCH_DUMP_FINISH;
}


/* Main computational kernel. The whole function will be timed,
   including the call and return. */
void kernel_trmm(int m, int n,
		 DATA_TYPE alpha,
		 DATA_TYPE POLYBENCH_2D(A,M,M,m,m),
		 DATA_TYPE POLYBENCH_2D(B,M,N,m,n))
{
  int i, j, k;

#pragma scop
  for (i = 0; i < _PB_M; i++)
    for (j = 0; j < _PB_N; j++)
      {
       for (k = i+1; k < _PB_M; k++)
          B[i][j] += A[k][i] * B[k][j];
       B[i][j] = alpha * B[i][j];
      }
#pragma endscop

}


int main(int argc, char** argv)
{
  /* Retrieve problem size. */
  int m = M;
  int n = N;

  /* Variable declaration/allocation. */
  DATA_TYPE alpha;
  POLYBENCH_2D_ARRAY_DECL(A,DATA_TYPE,M,M,m,m);
  POLYBENCH_2D_ARRAY_DECL(B,DATA_TYPE,M,N,m,n);

  /* Initialize array(s). */
  init_array (m, n, &alpha, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Start timer. */
  polybench_start_instruments;

  /* Run kernel. */
  kernel_trmm (m, n, alpha, POLYBENCH_ARRAY(A), POLYBENCH_ARRAY(B));

  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;

  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(m, n, POLYBENCH_ARRAY(B)));

  /* Be clean. */
  POLYBENCH_FREE_ARRAY(A);
  POLYBENCH_FREE_ARRAY(B);

  return 0;
}

```
</details>

<details><summary>mvt</summary>

```c
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <math.h>
//PolyBench common header files
#include <polybench.h>
//Benchmark-specific header file
#include "mvt.h"
/* Array initialization. */
static
void init_array(int n,
		DATA_TYPE POLYBENCH_1D(x1,N,n),
		DATA_TYPE POLYBENCH_1D(x2,N,n),
		DATA_TYPE POLYBENCH_2D(A,N,N,n,n))
{
  int i, j;
  for (i = 0; i < n; i++) {
    x1[i] = (DATA_TYPE)(i % n) / n;
    x2[i] = (DATA_TYPE)((i + 1) % n) / n;
    for (j = 0; j < n; j++)
      A[i][j] = (DATA_TYPE)(i*(j+1) % n) / n;
  }
}
/* DCE code. Must scan the entire live-out data.
   Can be used also to check the correctness of the output. */
static
void print_array(int n,
		 DATA_TYPE POLYBENCH_1D(x1,N,n),
		 DATA_TYPE POLYBENCH_1D(x2,N,n))
{
  int i;
  POLYBENCH_DUMP_BEGIN("x1");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "
");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, x1[i]);
  }
  POLYBENCH_DUMP_END("x1");
  POLYBENCH_DUMP_BEGIN("x2");
  for (i = 0; i < n; i++) {
    if (i % 20 == 0) fprintf (POLYBENCH_DUMP_TARGET, "
");
    fprintf(POLYBENCH_DUMP_TARGET, DATA_PRINTF_MODIFIER, x2[i]);
  }
  POLYBENCH_DUMP_END("x2");
}
/* Main computational kernel. The whole function will be timed,
   including the call and return. */
static
void kernel_mvt(int n,
		DATA_TYPE POLYBENCH_1D(x1,N,n),
		DATA_TYPE POLYBENCH_1D(x2,N,n),
		DATA_TYPE POLYBENCH_2D(A,N,N,n,n))
{
  int i, j;
  for (i = 0; i < _PB_N; i++)
    for (j = 0; j < _PB_N; j++)
      x1[i] = x1[i] + A[i][j] * x2[j];
  for (i = 0; i < _PB_N; i++)
    for (j = 0; j < _PB_N; j++)
      x2[i] = x2[i] + A[j][i] * x1[j];
}
int main(int argc, char** argv)
{
  /* Prepare ctuning vars */
  long ct_repeat=1;
  int ct_return=0;
  /* Retrieve problem size. */
  int n = N;
  /* Variable declaration/allocation. */
  POLYBENCH_1D_ARRAY_DECL(x1, DATA_TYPE, N, n);
  POLYBENCH_1D_ARRAY_DECL(x2, DATA_TYPE, N, n);
  POLYBENCH_2D_ARRAY_DECL(A, DATA_TYPE, N, N, n, n);
  /* Initialize array(s). */
  init_array (n, POLYBENCH_ARRAY(x1), POLYBENCH_ARRAY(x2), POLYBENCH_ARRAY(A));
  /* Start timer. */
  polybench_start_instruments;
  /* Run kernel. */
  kernel_mvt (n, POLYBENCH_ARRAY(x1), POLYBENCH_ARRAY(x2), POLYBENCH_ARRAY(A));
  /* Stop and print timer. */
  polybench_stop_instruments;
  polybench_print_instruments;
  /* Prevent dead-code elimination. All live-out data must be printed
     by the function call in argument. */
  polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(x1), POLYBENCH_ARRAY(x2)));
  /* Be clean. */
  POLYBENCH_FREE_ARRAY(x1);
  POLYBENCH_FREE_ARRAY(x2);
  POLYBENCH_FREE_ARRAY(A);
  return ct_return;
}
```

</details>

# 12/22(Sun)
LLMの性能を最大化するための手法  
1. 効率的なトレーニング: 計算リソースを削減しつつ制度を維持する方法   
2. 推論速度の向上: 推論パイプラインの最適化  
3. モデルサイズの最適化: プルーニングや蒸留による軽量化  
4. リソース管理: メモリと計算コストのバランス

※プルーニング:ノード間の重みが小さい箇所の接続を削除する、または影響の小さいノードを削除することでパラメータ数を削減する手法  
<img width="443" alt="image" src="https://github.com/user-attachments/assets/bc7fa0cb-f2fb-4e0c-8ea2-4727c29ad64d" />  
※蒸留:一度学習したモデルの知識（予測結果）を別の小さいモデルに継承する  
<img width="296" alt="image" src="https://github.com/user-attachments/assets/a8dc6f58-5c5a-4b78-9c6a-0644f06497d2" />  

### fine-tuningの新しい方法  
**1. 直接優先最適化(Direct Preference Optimization)**  
固定ターゲットではなく、応答の比較に基づいてモデルをカスタマイズできる。モデルに好みの出力と好みではない出力を区別するように教える。これは、トーン、スタイル、創造性が重要となる主観的なタスクに特に効果的である。  

**1.1. DPOとは**  
Direct Preference Optimizationは、大規模言語モデルを人間の嗜好に合わせてモデル重みを直接調整する革新的なアライメント手法である。RLHF(Reinforcement Learning from Human Feedback)のように報酬モデルを用意する必要がなく、バイナリな好み(正/不正といった単純な二択)に基づいて学習を行う。これにより、DPOはRLHFと同等のアライメント効果を保ちながら、計算的負荷を軽減し、より高速な学習を可能にする。  

**1.2. DPOが有用な理由**  
DPOは、明確な正解がない状況や、トーン、スタイル、特定のコンテンツ指向といった主観的要素が重要となる場合に特に効果を発揮する。この手法により、モデルは「望ましい(好まれる)」例と「望ましくない(好まれない)」例の両方から学習し、最終的に人間の期待により近い出力を生成できるようになる。   
- シンプルさ  
  DPOは、RLHFのように報酬モデルを別途作成する必要がない。これにより、最適化プロセスの複雑さが大幅に軽減される。  
- 安定性  
  人間の嗜好に直接基づいてポリシーを最適化することで、複数のモデルを訓練・維持する際の不安定性を回避できる。この結果、一貫性が高く信頼性のある出力が得られる。  
- 効率性  
  DPOは報奨モデルを持たないため、RLHFに比べて計算コストが大幅に削減される。これにより、学習の収束が速く、計算リソースのオーバーヘッドも低減される。  
- バイアス軽減  
  DPOは、人間の好みを直接最適化プロセスに取り込むことで、モデル出力に潜む意図しないバイアスの低減に役立つ。これにより、モデルはより望ましく、倫理的にも適合した出力を生成しやすくなる。  

総合的に、DPOは伝統的な手法に代わる簡易で安定かつ効率的アプローチであり、人間の期待や価値観により適合した言語モデルの微調整を可能にする。

**2. ビジョンファインチューニング**  
画像のセットをアップロードすることで、モデルをカスタマイズして、視覚検索機能の強化、自律走行車のオブジェクト検出の改善、より正確な医療画像分析など、特定のタスクに対する画像理解を強化できる。  
Vision Fine-Tuningの利用例  


 **2.1. 道路上の画像検出と理解の向上**
   フードデリバリーおよびライドシェア会社である「Grab」は、わずか100画像の「Vision Fine-Tuning」を使用して、「GPT-4o」に交通標識を正しくローカライズし、マッピングデータを改良するために車線区切りを数えるように教えた。その結果、基本的な「GPT-4o」よりも車線カウント制度を20％向上させ、制限速度標識のローカライズを13％向上させることができ、以前の手動プロセスからマッピング操作をより自動化できるようになった。  


**2.2. ビジネスプロセスを自動化するデスクトップボットの成功率の向上**  
     エンタープライズオートメーション企業である「Automat」は、「Vision Fine-Tuning」とスクリーンショットのデータセットを使用して、自然言語の説明が与えられた画面上のUI要素を見つけるように「GPT-4o」を学習し、RPAエージェントの成功率を16.60%から61.67%に向上させた。これは、基本的な「GPT-4o」と比較してパフォーマンスが272%向上した。さらに「Automat」は、情報抽出タスクのF1スコアを7％向上させるために、構造化されていない保険文書のわずか200画像を学習した。

**2.3. デジタルコンテンツ作成の品質を向上**   
     「Coframe」は、画像と既存のコードに基づいて「GPT-4o」にWebサイトの次のセクションのコードを生成するタスクを課した。「GPT-4o」を画像とコードでファインチューニングすることで、基本的な「GPT-4o」と比較して、一貫した視覚スタイルと正しいレイアウトでWebサイトを生成するモデルの能力を26%向上させた。　

**2.4. 安全とプライバシー**  
     ファインチューニングされたモデルで自動安全評価を継続的に実行し、アプリケーションが使用ポリシーに準拠していることを確認するために使用状況を監視する。すべてのAPIサービスと同様に、「Vision Fine-Tuning」はエンタープライズプライバシーのコミットメントの対象になる。ファインチューニングされたモデルは、ビジネスデータを完全に所有して、完全にコントロール下にある。


# 12/23(Mon)
### Llama 3.1 Swallow 8B Instruct v0.3  
v0.3では、新たに開発されたデータで指示チューニングを実施し、日本語のマルチターン対話能力を改善した。日本語MT-Benchの平均スコアにおいて、v0.2からv0.3で8.4ポイントの性能向上が得られ、このクラスのモデルの中ではトップクラスのスコア(0.6424)を達成した。また、マルチターン対話時の指示追従能力を改善した。v0.2とv0.3の違いは指示チューニングのみで、ベースモデルはLlama 3.1 Swallow 8B v0.2で共通である。  

常識的な知識を問う質問応答タスク、言語生成能力を測定する自動要約や機械翻訳、一般教養を問う試験問題、論理的思考力を反映すると言われる数学やコード生成のタスクを取り入れ、日本語理解・生成タスクとして9件のデータセットで評価実験を実施している。また、日本語の対話能力を測定するため、GPT-4をジャッジとした日本語MT-Benchの評価を行っている。  

全てのタスクにおいて、評価スコアは0(最低)から1(最高)までの範囲の値をとる。なお、日本語MT-Benchの評価結果が(たとえスコアを10倍して10点満点に換算しても)外部リーダーボードの評価結果よりも低いことが確認されている。多くの外部リーダーボードが応答文の評価にGPT-4(gpt-4-0613)を利用しているが、今回はGPT-4(gpt-4-1106-preview)を利用しているため、スコアの相違を引き起こしていると推測される。調査の結果、外部リーダーボードの評価結果には大きな差異があるものの、モデル間の順位はほとんど変わらないことがわかった。そのため、(すでに多くの評価を完了していたこともあり)GPT-4のバージョンを変更せず評価を続行している。  



# 12/24(Tu)
LLMによるpolybenchのソースコードを実行した。全体的に構文ミスが多く見られ、コンパイル可能なものは少ししかなかった。さらに結果がもとのpolybenchと同じになるものはさらに少なかった。  



| |コンパイル|元のコードとの結果比較|備考|
|:----|:----|:----|:----|
|2mm|☓|☓|括弧がないため構文エラー(\nも抜けている)|
|3mm|○|○| |
|adi|○|×|コンパイルは出来たが結果が異なった|
|atax|×|×|括弧がないため構文エラー|
|bicg|×|×|print_array関数の引数が足りない(int n) temp-q[0:N]=0の書き方がCではできない|
|cholesky|○|×|コンパイルはできたが結果が異なった|
|correlation|☓|×|init_array内のLARGE＿FLOAT_NがNである DATA_TYPE fn=(DATA_TYPE)LARGE_FLOAT_N;が不必要|
|covariance|☓|×|init_array内のLARGE＿FLOAT_NがNである DATA_TYPE fn=(DATA_TYPE)LARGE_FLOAT_N;が不必要|
|deriche|×|×|init_arrayのimgIn[i][j]での括弧がたりない imgOutがない　kernel_deriche内で定義されていない変数がいる|
|doitgen|○|○| |
|durbin|○|×|コンパイルは出来たが結果が異なった|
|fdtd-2d|○|○| |
|floyd-warshell|○|○||
|gemm|×|×|括弧がないため構文エラー|
|gemver|○|○| |
|gesummv|○|○| |
|gramschmidt|○|☓|コンパイルは出来たが結果が異なった|
|heat-3d|○|×|コンパイルは出来たが結果が異なった|
|jacobi-1d|○|×|コンパイルは出来たが結果が異なった|
|jacobi-2d|○|×|コンパイルは出来たが結果が異なった|
|lu|×|×|括弧がないため構文エラー|
|ludcmp|×|×|括弧がないため構文エラー|
|nussinov|○|○||
|seidel-2d|○|○||
|mvt|×|×|括弧がないため構文エラー|
|symm|○|×|コンパイルは出来たが結果が異なった|
|syr2k|×|×|print_array関数の引数が足りない(int m)|
|syrk|×|×|print_array関数の引数が足りない(int m)|
|trisolv|○|×|コンパイルはできたが結果が異なった|
|trmm|○|×|コンパイルは出来たが結果が異なった|

# 12/26(Thu)
構文エラーの部分を手動で(直せる範囲で)直してコンパイルしてみる。直せる範囲は引数を加える、括弧をつける、\nをつけるにとどめた。  
| |コンパイル|元のコードとの結果比較|備考|
|:----|:----|:----|:----|
|2mm|☓|☓|kernel_2mm 関数に渡す引数のポインタ型が一致しない(warning: passing argument 10 of ‘kernel_2mm’ from incompatible pointer type [-Wincompatible-pointer-types] # define POLYBENCH_ARRAY(x) *x)|
|atax|○|×|コンパイルは出来たが結果が異なった|
|bicg|×|×|A の型が関数内で定義された型と一致していない(error: conflicting types for ‘A’; have ‘double (*)[1900]’    DATA_TYPE POLYBENCH_2D(A, N, M, n, m)) {)|
|correlation|○|×|コンパイルは出来たが結果が異なった。|
|covariance|○|×|コンパイルは出来たが結果が異なった|
|deriche|○|○||
|gemm|×|×|A という識別子が異なる種類で再宣言されている(error: ‘A’ redeclared as different kind of symbol) 配列 C の定義やアクセスの方法に問題(error: assignment to expression with array type  C[i][j] *= beta;)|
|lu|○|×|コンパイルはできたが結果が異なった|
|ludcmp|○|×|コンパイルは出来たが結果が異なった|
|mvt|○|×|コンパイルは出来たが結果が異なった|
|syr2k|×|×|関数の引数の呼び出しが少なすぎる(error: too few arguments to function ‘print_array' polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(C)));)|
|syrk|×|×|関数の引数の呼び出しが少なすぎる(error: too few arguments to function ‘print_array’ polybench_prevent_dce(print_array(n, POLYBENCH_ARRAY(C)));)|
