# 9/8(Mon)

<details><summary>AIがソフトウェアを実際に構築できない理由</summary>

ChatGPTなど多くのLLMが人間並みのコーディング能力を持つようになったというベンチマーク結果が多数登場しており、ソフトウェア開発においてAIが活用される潮流が生じつつある。ところが、コードエディタ「[Zed](https://zed.dev/)」の開発チームの一員であるコンラッド・アーウィン氏は、「LLMはソフトウェアを実際に構築することはできない」として、その理由を説明している。

Why LLMs Can't Really Build Software-Zed's Blog  
https://zed.dev/blog/why-llms-cant-build-software  

https://zed.dev/blog/why-llms-cant-build-software<img width="560" height="350" alt="image" src="https://github.com/user-attachments/assets/b5ca7e4e-cd54-4a10-b187-26ce979ef2f1" />  

アーウィン氏が長年人間のソフトウェアエンジニアの仕事を見ている中で気づいたのは、人間が常に(メンタルモデル)[https://ja.wikipedia.org/wiki/メンタルモデル]を構築するというものであった。メンタルモデルとは、頭の中で行動をイメージするようなもので、有能な人間は大抵の場合以下の動作を繰り返していたとのこと。

- 要件のメンタルモデルを構築する
- その要件を満たすコードを書く
- コードが実際に何をしているかのメンタルモデルを構築する
- 違いを特定し、コードまたは要件を更新する

アーウィン氏は「有能なソフトウェアエンジニアの特筆すべき点は、明確なメンタルモデルを構築し維持する能力である。一方でLLMは違う。LLMはコードを書くのが非常に上手で、問題点を特定して修正する際のコードの更新もある程度は可能である。実際のソフトウェアエンジニアがやるようなこと、コードを読む、テストを実行する、ログを追加するなどもできる。しかし、彼らができないのは、明確なメンタルモデルを維持することである。」と指摘。  
アーウィン氏の肌感覚では「LLMは無限に混乱するもので、自分が書いたコードが実際に機能すると仮定し、テストが失敗すると、コードを修正するべきかテストを修正するべきか推測するしかなく、インライしてすべてを削除して最初からやり直す」という印象があり、ここが人間と大きく違い、与えられた文脈を見直して問題点を導き出すような処理ができないと主張している。  
ソーシャルサイトのHacker Newsでは、「人間は一歩引いて全体を俯瞰しつつ問題の根本原因を特定することができる」と補足されていた。  
アーウィン氏は「人間のソフトウェアエンジニアは作業は進める中でテストを実施する。テストが失敗すると、メンタルモデルを確認してコードを修正するかテストを修正するか、または決定を下す前に追加のデータを集めるかを判断できる。イライラすると、話し合いを通じて助けを求めることができる。そして、時々全てを削除して最初からやり直すこともあるが、その際は問題の理解がより明確になる」と人間の特徴を分析。  

一方、AIには以下のような欠点があるとしている。  

- モデルは欠落した文脈を見つけるのが苦手
- 新しく入力された情報ほど正しいと錯覚しがち
- 誤った情報を事実として主張する幻覚に陥る



アーウィン氏は「要件が明確で、問題が単純であれば、一度で完了できる。ところが、より複雑なタスクでLLMは文脈を正確に維持できず、解決策を提示するための反復作業に取り組めない」とまとめている。

</details>

# 9/9(Tue)

<details><summary>「なぜAIは嘘をつくのか？」OpenAIが論文を公開</summary>

OpenAIは９月５日、言語モデルで発生するハルシネーションのげんいんについて研究結果を公開した。同社では、言語モデルで用いられる事前学習やベンチマークの手法に原因があるとしている。  

ハルシネーションは、言語モデルが生成する回答のうち、もっともらしく見えるが実際には誤っているものを指す。言語モデルの開発における重要な問題で、発生を抑えるための改良が進められている。同社では今回の研究を通じて、ハル氏ネーションが発生する要因として、事前学習の仕組みと、ベンチマークテストの評価手法をあげた。

言語モデルでは、膨大なテキストから次に続く単語を予想するプロセスを通じて事前学習を進めていく。この際、各テキストに正誤のようなラベルはなく、文脈的に正しいかを認識している。このとき、単語のつづりなど一貫したパターンのあるものは学習とともにエラーが発生しなくなるが、論文のタイトルや人の誕生日など、出現頻度の低い任意の情報は予測ができない。これがハルシネーションの原因となる。  

また、標準的なベンチマークテストではAIモデルの性能を正解率の高さで評価することが多い。しかしこの場合、AIモデルが分からないことを「分からない」と答えると評価されないが、推測でそれっぽく答えるとたまたま正解してしまうことがある（誤った場合はハルシネーションになる）。その結果、正直に分からないと答えるより、当てずっぽうで答えるモデルの方がスコアが優位になってしまう現象が起きるという。  

同社では、ハルシネーションの抑制にはAIモデルが「分からない」と答えることが有効だと説明。ハルシネーションの評価手法を新たに導入するだけでは不十分であり、推測での回答を抑制するよう既存のベンチマークを再設計する必要があると指摘した。また、自社のモデルにおいてもハルシネーションの発生率を抑えるために尽力しているとアピール。

</details>

# 9/11(Th)

<details><summary>最低限のNetwork知識</summary>

# ネットワークモデルのoverview
コンピューターのネットワークはコンピュータ同士プロトコルという決まり事に沿って通信を行うことで意思疎通を図っている。このプロトコルは多数あり、類似したものを同じ階層に分けてモデル化し考えるのが一般的である。例えば、以下の図はOSIモデルと呼ばれる７層に分かれたプロトコル。  

- アプリケーション層
プログラマーが意識する部分（HTTP,DNS等）

- プレゼンテーション層
データの表現形式。テキストファイルをASCIIコードのファイルへ変換とか

- セッション層
通信プログラム間の通信の開始から終了までの手順

- トランスポート層
エンド間の通信制御（TCP,UDP等）

- ネットワーク層
通信相手への最適な経路を決定（IP,ICMP等）

- データリンク層
隣接するデバイス同士の通信（Ethernet等）

- 物理層
物理層な接続。1,0のビット情報を取り扱う

<img width="560" height="500" alt="image" src="https://github.com/user-attachments/assets/7576fc96-e6c5-432b-b437-db458f117d4b" />  


プロトコルはすでに定められているが、そのプロトコルがどの層に所属するのかは恣意的に決めることができる。よって上記の７層モデルが絶対ではなくTCPモデルでは４層で定義されていたり、[tenenbaum本](https://www.amazon.com/Computer-Networks-5th-Andrew-Tanenbaum/dp/0132126958)では５層モデルで説明が進められている。  

# データリンク層とARP
誤解を恐れずにいうと同じLANケーブルで繋がっているコンピュータ同士は直接通信することができる。通信は物理層で行われる0,1の激しいやりとりによって、一塊の情報を通信相手に送っている。送りたい情報が膨大だったり、複数ある場合は分割して分割された塊を相手側でガッチャンコすることで情報を復元させる。この一個の塊のことをフレームと呼ぶ。ざっくりとした図は以下のようになる。  
<img width="1282" height="148" alt="image" src="https://github.com/user-attachments/assets/8b61ba95-292b-4847-9700-2dd4d875d373" />

Payloadには基本的にパケットが入っていると考えればよく、Headerには送信先のMACアドレスと送信元のMACアドレスが記載されている。MACアドレスとはMedia Access Controlアドレスの略で製造メーカー他から各コンピュータに一意に振られている。（だが、VMを立ち上げたりすると仮想的に作ることもできたり、厳密には一意ではない。）このアドレスをもとにフレームは通信相手のコンピュータを探すことになる。  
ここで湧いてくる疑問。  

- どうやって相手のMACアドレスを知る？
普通プログラマーがどこかのコンピュータを通信したい時は、IPアドレスでプログラム上で指定したり、自分のパソコンでさえもlocalhostや127.0.01(この場合はloopbackという)と指定したりするはず。すなわち、コンピュータ同士で通信する時はIPアドレスを基にして相手を探しているわけである。しかし、IPアドレスとはいわばソフトウェアが勝手に付与するものであり、例えばDHCP（Dynamic Host Configuration Protocol）サーバー等を使っていればころころアドレスが変ってしまう。このIPアドレスを使ってそのコンピュータが所属するネットワークの場所を特定するまでがネットワーク層の仕事で、そのネットワーク内で実際にフレームを届けるのはデータリンク層の仕事となる。

さて、どうやって相手のMACアドレスを知る？の疑問の答えはARPというプロトコルになる。ARPとは同じネットワーク内で端末のIPアドレスを使ってMACアドレスを聞き出すプロトコルである。以下にARPの流れを示す。

まずは以下の図を想定。PC1とPC2は同じネットワーク内にあるものとする。ルーターを超えると違うネットワークとなり、172.16.1.0/24がネットワークのアドレスを表している。同じネットワークのことをセグメントとかブロードキャストドメインと呼んだりする。それぞれMACアドレスはMAC1,MAC2と記載している。また、ルーターもポートごとにIPアドレスとMACアドレスを有している。  
<img width="680" height="338" alt="image" src="https://github.com/user-attachments/assets/a8f8252f-c456-4bd9-a12e-c46c392f3f20" />  
PC1がPC2のIPアドレスを知っていてMACアドレスを知らない場合。以下のようにPC1がネットワーク全体にMACアドレスを聞いて回る。  
<img width="610" height="266" alt="image" src="https://github.com/user-attachments/assets/4bf2668c-910d-45fe-9132-fc1807aa1901" />  

PC2は自分のIPアドレスを知っていて172.16.1.3と一致しているため、自分のMACアドレスがMAC2であることをネットワーク全体に伝える。この時ルーターもPC1の質問を聞いているが自分のIPアドレスではないため無視する。  
<img width="570" height="234" alt="image" src="https://github.com/user-attachments/assets/d53a67e8-e917-4061-b410-fac89c476413" />  

こうしてPC1は172.16.1.3のMACアドレスがMAC2と知ることが出来る。  

この一連の流れをARP（Address Resolution Protocol）と呼び、同じネットワークにいるコンピュータ同士お互いのMACアドレスを教え合っている。上記の場合、ルーターは会話に参加していないが会話の内容は全てキャッチしているので、PC1が得た情報を得ることができる。このPC1がやったようにネットワーク全体に向かって発信することをブロードキャストと呼ぶ。また、APRで得られたIPアドレスとMACアドレスの対応表はARP tableと呼ばれ、  
```
arp -a
```
というコマンドで確認できる。  
- MACアドレスがわかったところでどうやって相手にフレームを届ける？
上の例でARPを使いPC1がPC2のMACアドレス情報を入手し、その後フレームをPC2に届けたいとする。これをどう届けるかはプロトコル次第になるが最も簡単な例は同一のネットワーク内にブロードキャストを行いフレームを送りつけるやり方である。
フレームのHeaderには送元と行先のMACアドレスがあるので、誰が誰に送っているかの情報が分かる。そしてフレームを受け取ったPC2は自分宛のフレームがMAC1から送られてきたので後続の処理を行う。
ルーターは自分宛ではないフレームなので無視することになる。
<img width="740" height="366" alt="image" src="https://github.com/user-attachments/assets/70dcfb72-3fa3-47b0-83ef-c8bb60c619b5" />

以上のようにして、互いのMACアドレスを確認しあってフレーム単位で通信を行うのがデータリンク層の大きな仕事の一つとなる。  

# ネットワーク層とルーティングテーブル
先ほどの例では同じセグメント内にいる場合の通信の仕方を説明した。しかし、同じセグメントとはごく狭いLANの一部の話であり、違うネットワークのコンピュータと通信したいことは往々にしてある。（セグメントが大きくなると多数のコンピュータにフレームが届いて通信の効率が悪くなる。）では、その場合どうするか？  

ここでルーターが登場する。先ほどの例でもルーターが出ていたがこのルーターの別のポートが違うネットワークのEthernetにつながっている。下の例でいうとPC1とPC2とルーター1のport1が同じセグメント、PC3とルーター1のport2とルーター2のport1が同じセグメント、PC4とルーター2のport2が同じセグメントというくくりになる。  

<img width="1054" height="254" alt="image" src="https://github.com/user-attachments/assets/6bbfd006-0f7f-4111-b642-dc666c546b6b" />  

ルーターではIPアドレスの情報を頼りにして宛先が所属するネットワークを探す。データリンク層ではMACアドレスを使うという話をした。今回はIPアドレスを使うのでネットワーク層の話となる。つまり、ルーターとはネットワーク層のIPプロトコルを使用して働くデバイスということである。  

データリンク層の話ではフレームという単位で情報のやりとりをするという話をした。  
<img width="1282" height="148" alt="image" src="https://github.com/user-attachments/assets/95e11aa2-5d91-4578-ab8c-29350c36e426" />  

このHeaderには前述の通りMACアドレスの情報が入っている。ではIPアドレスの情報はどこにあるのかというとこのPayload fieldに入っている。これがいわゆるパケットと呼ばれるもの。  
パケットのHeaderは以下のようになっている。  
<img width="1400" height="664" alt="image" src="https://github.com/user-attachments/assets/4941f673-6621-400b-9d64-4d4399ce045b" />  
いろいろ書いてあるが、IPアドレスはSource addressとDestination addressのフィールドに入っていることになる。つまり、データリンク層のプロトコル(e.g. Ethernet)でフレームのHeader情報が使われ、その一個上であるネットワーク層のプロトコル(e.g. Internet Protocol)ではフレームのHeaderが剥がされて現れたパケットの両端に情報が足されたり、剥がされたりして層ごとにそれぞれの仕事を行っている。ルーターも含めコンピュータはそれぞれルーティングテーブルを保有している。そこには宛先のIPアドレスごとにどこにパケットを送るべきかという情報が記載されている。ちなみに以下コマンド、  
```
ip router
```
でそのコンピュータが持っているテーブルが出てくる。  

ではルーターがどのようにネットワークを探すのかを見ていく。まずは以下の図が今回考えるネットワーク構成だととする。  
<img width="1100" height="468" alt="image" src="https://github.com/user-attachments/assets/133c0a03-a540-4871-af45-f0438d16738a" />  
ルーター1とルーター2を挟んで3つのセグメントがある構成である。ここでPC1がPC4と通信したいとする。ここでは前に見たフレームの話も含めて説明する。ただし、それぞれネットワーク内でARPは既に行われ、それぞれのコンピュータがARP Tableを保有しているとする。まず、PC1のルーティングテーブルには以下のようになっているとする。  
<img width="1266" height="218" alt="image" src="https://github.com/user-attachments/assets/1ffc2487-54ad-46a0-bf5f-d26a043ca4de" />  

上記テーブルの意味は通信したい相手が172.16.1.3(PC2)であればルーターを返す必要がないので次の宛先が - 、すなわち同ネットワーク内で前のブロードキャストを行えば良い。それ以外が宛先の場合(0.0.0.0)、ルーター1を経由する必要があるので次の宛先を172.16.1.1(ルーター1のport1)とする。この、0.0.0.0はデフォルトルートと呼ばれ、一般家庭のPCだとWiFiルーターを向いていることがほとんどのはず。  

さて、上でPC1が通信したい相手はPC4(12.16.3.2)なので上記のテーブルによると、まず172.16.1.1（ルーター1のport1）に向かうことになる。もちろん、このルーターまで向かう場合でも同じネットワーク内での通信は前述したブロードキャストによって通信する。なのでフレームは以下の様になる。  

<img width="926" height="248" alt="image" src="https://github.com/user-attachments/assets/23735e7a-5ea9-44c5-9a7e-ecc33fbd919f" />  

ポイントはフレームの宛先はルーター1のport1のMACアドレスであるが、パケットの宛先はPC4のIPアドレスである。フレームを扱うEthernet（データリンク層）では同じセグメント内のブロードキャストで使うため、フレームのHeaderにはルーター1のport1のMACアドレスが入る。そして、パケットを使うインターネットプロトコル（ネットワーク層）ではあくまで最終目標地点のPC4のIPアドレスを保持しておく必要がある。  

次にルーター1のルーティングテーブルを見てみる。   

<img width="1266" height="292" alt="image" src="https://github.com/user-attachments/assets/9cadec59-91bf-4aa7-a233-a27857723bff" />  

先ほど見たルーティングテーブルで説明済みなので特に説明はしないが、今回の宛先はPC4（12.16.3.2）なのでデフォルトルートとなりルーター1のport2からルーター2のport1を目掛けて通信する。例によって、この通信は同じセグメント内なのでEthernetの出番となる。フレームは以下の様になる。これも前述の通りとなる。  

<img width="938" height="260" alt="image" src="https://github.com/user-attachments/assets/1ef432eb-3a81-4ef1-b8f6-387b3f9d2671" />  

次にルーター2のルーティングテーブルを見てみる。  

<img width="1280" height="362" alt="image" src="https://github.com/user-attachments/assets/9f643391-84d6-4e81-8902-d7b1c82c72c4" />  
デフォルトルートの次の宛先に次ぎのルーターと記載したがネットワーク構成が右に続いていると考えて欲しい。通信したい相手はPC4（12.16.3.2）は172.16.3.0/24のネットワークにいるのでこれ以上ルーターリレーをする必要はなく、ここでブロードキャストを使いフレームを届けることができる。フレームは以下の様になる。このフレームを届けることで無事に中のパケットがPC1からPC4に届けられる。  

<img width="926" height="252" alt="image" src="https://github.com/user-attachments/assets/e8f0552c-4b8d-4d5a-8041-4f228ce9364e" />  

# NAT
Network Address Translationすなわちアドレスのマッピングを行っている。一番わかりやすい例はprivateアドレスからglobalアドレスへの変換。  
例えば、private IPアドレスが192.168.100.101だったとしても8.8.8.8にアクセスしたいとする。以下のアドレスは予めPrivate IPアドレスの領域として定められているため、ルーターはこれがPrivateアドレスだと分かる。  
10.0.0.0-255.255.255  
172.16.0.0-172.31.255.255  
192.168.0.0-192.168.255.255  

8.8.8.8はインターネット上に公開されているアドレスなので外部のルーターを伝っていくが、この時送り元のアドレスがPrivate IPアドレスのままだとパケットを破棄されてしまう。（PrivateアドレスはLAN専用なのでいろんなコンピュータとかぶりまくり。）  

なのでパケットが外部に出るときに、送りもとアドレスをGlobal IPアドレスに変換してあげる必要がある。これがNATである。このNATルーターがLANの外部の境におかれることになる。  

上記の例であれば、以下のように送信元のアドレスを変えてしまう。そして、変える前と変えた後のアドレスのマッピング表を保持しておく。（これをNATテーブルと呼ぶ。）  

<img width="1260" height="208" alt="image" src="https://github.com/user-attachments/assets/4744e82d-4ac8-474e-9e50-a574185034fd" />  
8.8.8.8からのレスポンスは203.0.113.2宛にくるがNATルーターがこれをprivate IPアドレスに変換して本来の送り元に届けられることになる。  

一方この変換はPrivate IPとGlobal IPが1対1に対応していて、Private IPの数だけGlobal IPを用意する必要があり、現実的ではないためポートも含めてマッピングするIPマスカレードが一般的である。  

# Dockerのネットワーク
今回のdockerのbridgeとhostのネットワークについて説明する。  

- **bridge**
Dockerはdefaultではbridgeネットワークを自動で形成する。以下の図を参照。

<img width="1079" height="1400" alt="image" src="https://github.com/user-attachments/assets/b63109f8-aee4-431a-b4df-1375c3732ad6" />  
同じ物理サーバーの上に2つの点線枠があるが、これはName spaceと呼ばれるものでlinux仮想的にネットワークの観点で独立した環境を提供している。つまり、異なるNamespaceはいわば違うlinuxサーバーが存在していると考えるとわかりやすいかもしれない。そして、dockerを立ち上げると、docker0という仮想bridgeが立ち上がる。bridgeとはそこに繋がっているネットワークを1つのセグメントとしてつなぐ機能を持つ。つまりdocker0んい繋がっているコンテナ同士（上図は1個のコンテナのみだが）は同じセグメントに所属することになる。   

docker0というコンテナのeth0(ネットワークとコンテナのインターフェース)をつなぐvethは一個のテーブルが繋がっていると考えるとわかりやすい。  
このようにしてbridgeネットワークで立ち上げたdockerのコンテナ達はIPアドレスが127.17.0.1のdocker0という仮想bridgeに繋がっているため、お互いにブロードキャストで通信をし合うことができる。そして、Hostのnamespace上にある、eth0(コンピュータとネットワークの物理的なインターフェース)との間にある丸いものがNATルーターの役割を果たしていて、コンテナ内部からのパケット送信の際にdockerネットワークで使っているIPアドレスから、その物理サーバーのIPアドレスに変換してその変換表を持っておくことになる。このルーターはHost namespaceのサーバーがその役割を担っている。下表参照。  

<img width="1260" height="208" alt="image" src="https://github.com/user-attachments/assets/a2af2a84-7d59-4e5c-941a-77759dfc0c79" />  

もちろん、この後にインターネットに出て行く前に前述したNATルーターを通ってもう一度アドレスが変換されるが、両方のNATルーターとも変換表を保持しているため問題なく帰ってきたパケットを該当コンテナに返すことができる。  

一方でHost側（あるいは外部）からコンテナにアクセスしたい時に、コンテナのどのポートにアクセスすれば良いかという情報をNAT tableに予め書いておく必要がある。（ポートを開放するとはこのこと。）例えば上記のコンテナのポート80をホストのポート80とマッピングさせる場合、dockerのコマンドでは  
```
-p 80:80
```
のように書きNATテーブルは以下のようになる。これで外部からアクセスできるようになる。  

<img width="1258" height="212" alt="image" src="https://github.com/user-attachments/assets/55a7dd43-1f09-4a6e-87cb-64a9456f7d9d" />  

このようなNATをDestination NATと呼ぶ。前述のNATはSource NATと呼ぶ。  

- **host**
次にhostネットワークについて。これはデフォルトではなくdocker起動時に--net hostのオプションを指定する必要がある。
このネットワークはbridgeに比べると非常に単純でコンテナをHostのnamespace内に配置することになる。なので、コンテナのIPアドレスとホストマシンのIPアドレスが一致するため、サーバー内でNATルーターは必要なく、ポートマッピングをする必要もなくなる。単純に、コンピュータ内に別のプロセスが立ち上がっていると考えれば良さそう。

<img width="1400" height="1025" alt="image" src="https://github.com/user-attachments/assets/8b93dd1e-7107-4563-ba06-cb6ac20ca331" />  

Hostネットワークでは、例えば複数のコンテナで通信するような場合、listenしてるコンテナが複数同時に立ち上がるとポートが被ってしまうという問題があるので注意が必要。同じHost namespaceにいるの同じポートはどちらかのコンテナしか使えない。下図参照。  

<img width="1400" height="534" alt="image" src="https://github.com/user-attachments/assets/7c8d9e68-3d0b-4c94-af23-4ea2c2b42281" />  

Bridgeネットワークするとname spaceが異なるため、ポートが被っても問題なくなる。（仮想的に別マシンとなるのでポートが被ろうが関係ない。）下図参照。  

<img width="1400" height="851" alt="image" src="https://github.com/user-attachments/assets/a8737a66-639e-4649-a74a-85e267a2e6c6" />  

</details>

# 9/17(Wed)
<details><summary>「テストだと×」なのに数学界では「間違い」と言い切れない...「インドの魔術師」が執念で導いた「1+2+3+4+...」の解</summary>

# 自然数を足し続けるとマイナスの数になる！？
「1+2+3+4+....=-1/12」  
```
問題
1+1/2+1/4+1/8+1/16+1/32+....を計算せよ。
```
最初の数は1。2番目は半分の1/2。3番目はさらに半分の1/4。4番目はそのまた半分の1/8。....と、足される数は順々に半分になっている。でも、足すべき数は全部で無限個ある。それぞれの分数を、小数に直す。  

<img width="1280" height="715" alt="image" src="https://github.com/user-attachments/assets/82726556-3826-4290-a8d0-99eef6818738" />  

# 「正体不明のモンスター数式」と対峙した数学者たち
ところが、数学では、これと同じように「無限個の数を足す」という問題がしょっちゅう現れる。例えば、1から初めて、分母が3倍ずつ大きくなっていく数をひたすら足し合わせる  
```
1+1/3+1/9+1/27+1/81+....=?
```
という問題や、どんどん大きくなる数を交互に足したり引いたりする  
```
1-2+4-8+16-32+....=?
```
という問題、あるいは自然数を全部足し合わせる
```
1+2+3+4+5+....=?
```
という問題まで。  
こういう問題、まるで正体不明のモンスターのようにも感じる。「.....」で表しているところとか、なんかごまかしているんじゃないかな？などと思ってしまいます。
# いったん100個だけ足してみる
このように無限個の数を足し合わせた形の式を、数学では「無限級数」と呼ぶ。
</details>
